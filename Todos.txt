Romanesco 証明エンジン 開発ロードマップ

1. 完了済み項目 (Done) ✅
- [x] **プラグイン指向アーキテクチャの基盤**: 
    - [x] フックベースの検索プラグイン (`LogicPlugin`)
    - [x] 基底 `Plugin` トレイトへの統合と優先度 (`priority`) 管理
    - [x] トポロジカルソートによる依存関係解決 (`PluginRegistry`)
    - [x] 機能セットのパック化 (`PluginPack`)
    - [x] 自然数・リスト・木構造などの代数計算プラグイン化 (`AlgebraPlugin`)
    - [x] 正規化エンジンのプラグインフック化 (`Rewriter` の汎用化)
- [x] **探索エンジン・最適化**:
    - [x] 完全Treeベースの並行分岐探索エンジン
    - [x] 動的な探索コスト・深さボーナス・失敗キャッシュの最適化
    - [x] 高階パターンユニフィケーションと動的 Pruning
    - [x] ウォッチドッグタイマーによる無限ループ遮断
- [x] **Solver基盤の抜本的強化 (Verification-oriented Updates)**:
    - [x] **線形コンテキストの等価書き換え**: 通常コンテキストの `A = B` (HoTT/Path) を用いた `linearContext` の動的変換の実装
    - [x] **順次消費型線形推論 (Sequential Consumption Model)**: 組み合わせ爆発を排除した効率的なリソース管理とフレーム推論の統合
    - [x] **統合型前向き・後ろ向き探索**: プログラム実行（ドミノ倒し）と構造分解の融合
- [x] **100% 検証精度の達成**: OmniVerificationTest, EnhancedFrameTest, LinearLogicTest の全パス
- [x] **メモリ安全の完全自動化 (Full Ownership Automation)**:
    - [x] **自動所有権推論コンパイラ**: 使用回数解析に基づく `Borrow`/`Move` の自動発行
    - [x] **コンパイル時自動メモリ管理**: `ResourceOptimizer` 統合による `Free` 命令の最適配置
- [x] **ホモトピー借用システム (Homotopic Borrowing)**:
    - [x] **Pathベースのライフタイム管理**: `Own(r)` と `Shared(r)` の間の Path による借用状態の幾何学的表現
    - [x] **ホモトピー的リソース消費**: パス上の端点を同一リソースとみなす透過的な推論ロジック
- [x] **高効率 LLVM バックエンド (Zig-inspired Optimizations)**:
    - [x] **スタックアロケーション自動化**: エスケープ解析による `alloca` (スタック) と `malloc` (ヒープ) の自動使い分け
    - [x] **自己完結型純粋 LLVM IR 出力**: 外部 C ファイルに依存しない単一 `.ll` ファイルによるネイティブコンパイル成功
    - [x] **包括的バックエンド検証**: `LLVMCodeGenTest` における 100% 合格率の達成
- [x] **各論理体系のサポート**: モナド三則、分離論理、Hoare論理、HoTT、余帰納法の統合
- [x] **ネイティブバイナリ生成基盤の確立**

2. 現在の最優先課題 (Priority:High) 🚀
- [x] **高度なクロージャと再帰のネイティブ実装**:
    - [x] 純粋 LLVM IR 内での関数ポインタと環境ポインタの厳密な管理
    - [x] 相互再帰や深いコールスタックの静的安全性保証
- [ ] **プラグイン導入の自動化**: リフレクションまたはマクロを利用した特定パッケージからのプラグイン自動検出・ロード

3. 短期・中期的な拡張項目 (Priority: Medium) ⏳
- [ ] **探索木の視覚化 (D3.js / Web UI) の統合**: `romanesco.Types.Tree` をブラウザでインタラクティブに描画
- [x] **ランタイム・コンパイラの高度化 (JIT/Native Integration)**:
    - [x] **LLVM ORC (lli) ベースの JIT 実行エンジン基盤の実装**
    - [x] **JIT における構造体 (Pair)・和型 (Sum)・所有権 (Borrow/Free) 操作の完全サポート**
    - [x] **JIT における自動メモリ管理**: `rt_cleanup_value` による malloc ポインタの自動開放
    - [x] **Registory への JIT 統合と動的実行環境の構築**
- [x] **投機的 JIT (Speculative JIT) の実装**:
    - [x] プロファイリング VM による実行時型情報の収集 (`ProfileData`, `ProfilingVM`)
    - [x] ガード命令と Deoptimization (Deopt) メカニズムの導入 (`rt_guard_int`)
    - [x] 全算術演算の型特化型 LLVM IR 生成による高速パスの構築
    - [x] 動的な実行切り替えエンジンの実装 (`SpeculativeExecutor`)
- [x] **シームレスな実行引き継ぎ (Seamless Execution Handover) の実装**:
    - [x] **基本的な Deoptimization (Deopt)**: PC 情報を利用した JIT から VM への復帰
    - [x] **精密な状態復元**: `rt_dump_regs` + Panama 同期による全レジスタの VM への復元
    - [x] **スタックマップ (Stack Maps) の導入**: `phi` 命令によるレジスタバッファの動的切り替え
    - [x] **On-Stack Replacement (OSR)**: `external_regs` 引数による VM から JIT への動的引き継ぎ基盤
- [x] **型無しランタイム最適化 (Untyped Runtime Optimization)**:
    - [x] **厳密な「型無し」アーキテクチャへの移行**: プロファイルVMおよびJITからの型依存性の完全排除
    - [x] **動적挙動プロファイリングの高度化**: 分岐予測、呼び出し先（インライン化ヒント）、値パターン（定数化）の記録
    - [x] **究極のビット幅最適化 (Arbitrary Bit-width iN)**: 1ビット単位の精度での最小ビット幅推論と LLVM `iN` 型へのマッピング
    - [x] **プロファイル駆動型 AOT (PGO-AOT)**: VMでの実測データに基づく「型無しネイティブ最適化」フローの確立
    - [x] **汎用的データ処理 (Generic Data Handling)**: 型チェックを介さずランタイムがデータの構造を動的に解釈する一貫した実行基盤
- [x] **統合ロギング基盤の整備**: `Debug.logger` による JIT・探索プロセスの可視化統合
- [x] **バイトコード・資源最適化 (Bytecode & Resource Optimization)**:
    - [x] **レジスタ再割り当て最適化 (`RegisterAllocator`)**: 生存期間解析に基づくレジスタ番号の再利用と最小化の実装
    - [x] **命令数削減パス (`BytecodeOptimizer`)**: 定数畳み込み (Constant Folding) と不要命令削除 (DCE) による実行ステップの最小化
    - [x] **最適化パイプラインの統合**: コンパイル、命令削減、所有権解析、レジスタ割り当てを統合した高効率なコード生成フローの構築

4. 目標 (Vision) 🎯
- [ ] あらゆる論理体系がシームレスに協力し、プログラムの性質を「完全に自動で」証明し、その証明に基づいた「数学的に正しい」超高速なネイティブコードを生成する究極の言語基盤。
