TODOリスト: 現在の証明器の主な課題（優先度順）

[DONE]【最優先】
[DONE]1. 単一化（unify）をバックトラッキング対応にする
   - Option[Subst] → Iterator[Subst] / LazyList[Subst] に変更
   - 複数の単一化候補を生成・試行（特に∀やメタ変数複数時）

[DONE]2. 探索戦略の改善（DFSの限界対策）
   - 幅優先探索（BFS）や iterative deepening を導入
   - visited判定を強化（コンテキストの順序や名前を考慮した比較）

[DONE]3. 失敗時の詳細情報記録・出力
   - None ではなく Either[FailTrace, Proof] のような形に
   - 失敗理由（どの規則、どのunify、どの深さで詰まったか）をトレース

[DONE]4. 仮定名の管理を安定化
   - 名前衝突を防ぐ自動生成ロジック強化（UID風 or 深さ+パスベース）
   - Tactics適用時の名前依存を減らす（名前ではなくインデックスや参照で指定）

[DONE]【中優先】
[DONE]5. 規則適用の効率化
   - rules を先頭シンボルでインデックス化（Map[Sym, List[CatRule]] など）
   - 不要な instantiate/unify をスキップ

[DONE]6. 古典論理（RAA）の柔軟性向上
   - raaCount制限を緩和 or 条件付きで複数回許可
   - ¬¬A → A などの古典公理を明示的に追加

[DONE]7. 高階・依存表現の基盤強化
   - Expr に λ抽象 / Pi型（依存関数）を追加検討
   - 高階単一化（higher-order unification）の準備

[DONE]8. 証明出力の可視化の改善
   - Proof をツリー構造（ProofTree）に変更
   - 自然言語風 / LaTeX / ツリー表示の生成機能追加

【低優先・将来的】
[DONE]- 並列探索・ヒューリスティック優先度（スコア）
[DONE]- 部分証明のキャッシュ / メモ化強化
[DONE]- エラー回復（部分成功時の返却）
- 外部規則ファイルからの動的ロード

--------------------------------------------------
【設計思想メモ: データ構造の圏論的アプローチ】
データ型の個別定義（自然数、リスト等）を避け、普遍性で扱うための選択肢：

1. 始代数 (Initial Algebra)
   - データを特定の関手 F の始代数として扱う。
   - 帰納法は「始対象から他の代数への一意な射 (Catamorphism / Fold)」の普遍性として実装。
   - 例: 自然数は F(X) = 1 + X の始代数。

2. 教会符号化 (Church Encoding)
   - 高階論理 (HOL) を利用し、データを関数として定義。
   - 帰納法は、高階の述語に対する多相的な全称量化で表現。
   - 追加の型システムなしで現在の Unifier と Lam で計算可能。

3. 随伴関手 (Adjunction)
   - リストを「集合圏からモノイドの圏への左随伴（自由モノイド）」として定義。
   - コレクションの操作を構造的な普遍性（unit/counit）として扱う。
--------------------------------------------------
今後の展望
   - 高階帰納法: ∀P. P(0) → (∀n. P(n) → P(S(n))) → ∀n. P(n) という公理を使って、任意の式に対する帰納法を自動で適用する（現在は Prover
     内部でハードコードされた帰納法ロジックを使っていますが、これを論理式レベルで扱えるようになります）。
   - 高階マッチングの強化: 定数引数を含むような、より柔軟なマッチング（例: ?f(0) = 0 から ?f = λx. x を推測するなど、複数解があるケースの探索）。