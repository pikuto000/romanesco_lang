# romanesco

**すべてが「適用（application）」である**プログラミング言語。以下の特徴を備えています：
- **非決定的レキシカル分析・構文解析** - あらゆる解釈の可能性を探索
- **制約ベースのセマンティクス** - 型システムの代わりに論理制約を採用
- **カスタマイズ可能な構文** - マクロによるミックスフィックス（Mixfix）演算子の定義
- **Z3 SMTソルバの統合** - コンパイル時の制約解消

名前の由来はカリフラワーの一種である「ロマネスコ」。そのフラクタル構造は、言語の再帰的で自己相似的な設計を反映しています。

## 哲学

romanescoはコア部分で過激なミニマリズムを採用しつつ、メタプログラミングによって表現力を最大化します。

1. **すべては適用である** - 唯一の原始的な操作は関数適用のみ
2. **型はなく、制約のみ** - SMTで検証された論理制約による安全性
3. **コンパイル時は非決定的、実行時は決定的** - 実行前にすべての曖昧さを解消
4. **デフォルトで衛生的マクロ** - 必要に応じて `@current` エスケープハッチを使用可能
5. **空白非依存** - `fx`, `f x`, `f    x` はすべて等価

## 現在のステータス

🚧 **開発初期段階** - コア・インフラストラクチャを構築中：

- ✅ メモ化付き非決定的レキサー
- ✅ 非決定的パーサー
- ✅ コア言語の評価器 (Evaluator) - ラムダ、関数適用、単一化によるパターンマッチ
- ✅ ミックスフィックス・マクロ定義のパース
- ⏳ Z3ソルバ統合（基盤は完了、ロジックは保留中）
- ⏳ 制約ベースのセマンティクス
- ⏳ LLVMバックエンド

## 必要要件

- **Scala** 3.7.4+
- **sbt** 1.12.0+
- **Z3** (`z3-turnkey` 依存関係経由)

## ビルド

```bash
sbt compile
```

## 使い方

```bash
sbt "run <input-file> [options...]"
```

**オプション:**
- `all`   - すべてのトークン化の可能性を表示（デフォルト）
- `best`  - 最長のトークン列のみ表示
- `topN:n`- 上位N個のトークン化を表示
- `eval`  - 評価フェーズを実行
- `debug` - デバッグ情報を表示

**例:**

```bash
sbt "run test.romanesco eval debug"
```

## サンプルコード

```romanesco
// リスト構築の定義
Cons = \a -> \b -> a and b
Nil = false

myList = Cons 1 (Cons 2 (Cons 3 Nil))

// パターンマッチを用いた関数
head = \x -> x = Cons first rest and head = first

result = head(myList) // result = 1
```

## アーキテクチャ

```
scala/
├── Main.scala           - エントリーポイントとCLI
├── Undeterminable/
│   └── Tree.scala       - 非決定的木構造
├── Lexing/
│   ├── Lexer.scala      - 曖昧さを保持したトークン化
│   └── Unlexer.scala    - トークン → 文字列（デバッグ用）
├── Parsing/
│   ├── Parser.scala     - 非決定的パーサー
│   └── AST.scala        - 抽象構文木（AST）
├── Core/
│   ├── Core.scala       - コア言語定義とPrelude
│   ├── Evaluator.scala  - 評価器（環境の伝播と単一化）
│   └── Translator.scala - AST → Core変換
└── Solver/
    └── Solver.scala     - Z3統合（進行中）
```

## 設計上の決定

### 非決定的レキシカル分析
レキサーは、木構造を使用して検索空間を効率的に表現し、**すべての可能なトークン化**を同時に探索します。メモ化により、各位置の処理は一度だけ行われます。

### 文の区切り
改行 (`\n`) およびセミコロン (`;`) を文の区切りとして採用しています。これにより、トップレベルの代入や制約を明快に記述できます。

### 論理積とデータ構造 (`and`)
`and` 演算子は論理積（制約の結合）であると同時に、値に対しては**ペア（タプル）構築子**として機能します。
- `true` との結合は identity として機能し、`false` は伝播します。
- `1 and 2` はペア `(1, 2)` を生成します。

### 空白の独立性
`fx` は以下のように解釈されます：
1. 単一の識別子 `fx`
2. `f` を `x` に適用する `f x`

パーサーと制約ソルバが、文脈に基づいて正しい解釈を決定します。

## ロードマップ

**フェーズ 1: 基盤構築** (現在)
- [x] 非決定的レキサー
- [x] 非決定的パーサー
- [x] 基本的なAST
- [x] コア言語評価器
- [ ] デリミタのバランス制約

**フェーズ 2: 制約**
- [ ] Z3制約の生成
- [ ] コンパイル時の制約解消
- [ ] 制約による曖昧さの解消

**フェーズ 3: セマンティクス**
- [x] ラムダ式
- [x] 制約ベースのパターンマッチング
- [ ] 衛生的なマクロ展開

**フェーズ 4: コード生成**
- [ ] LLVM IR生成
- [ ] 最適化パス
- [ ] バイナリ出力

## 哲学の詳細

### 「すべては適用である」
ラムダや束縛さえも適用として表現されます：
```romanesco
lambda(x, body)  // 内部的: apply(apply(LAMBDA, x), body)
let x = v in e   // 内部的: apply(lambda(x, e), v)
```

### 型より制約論理
`x: Int` と書く代わりに、以下のように記述します：
```romanesco
{
  x > 0;
  x < 100;
  compute(x)
}
```
Z3がコンパイル時にこれらの制約を検証します。

### エスケープハッチ付き衛生的マクロ
```romanesco
syntax define $name = $body = {
  bind($name, $body)  // 定義時の環境をキャプチャ
}

// 明示的な現在の環境へのアクセス
syntax debug $expr = {
  log("evaluating");
  @current $expr  // 呼び出し側の環境を使用
}
```

## 貢献について

本プロジェクトは実験的な研究プロジェクトです。フィードバックやアイデアは大歓迎ですが、設計の進化に伴い過激な変更が行われることを覚悟してください。

## ライセンス

未定（TBD）

## 謝辞

以下の影響を受けています：
- **Lisp** - データとしてのコード、マクロ
- **Haskell** - 優雅な構文、純粋性
- **Prolog** - 論理プログラミング、単一化
- **Nim** - メタプログラミング、コンパイル時実行
- **Forth** - ミニマリズム、セルフホスティング
