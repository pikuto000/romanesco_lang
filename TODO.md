# Romanesco プログラミング言語 開発ロードマップ

Romanesco は、Z3 ソルバーによる制約解決と、衛生的なマクロシステムを核とした「真に汎用な」型無し言語です。
特定の目的に縛られず、あらゆる言語の機能をプラグインとして取り込み、安全に実行・検証することを目指します。

---

## 🎯 設計思想（こだわり）
- **真の汎用性**: あらゆる表現ができ、あらゆる状況でトップパフォーマンスを発揮する。
- **ゼロ・シンタックス**: 必要な機能だけを `init` から選択し、目的に特化した言語をその場で構築する。
- **制約による安全**: 型システムの代わりに Z3 ソルバーを用い、実行前に論理的な正当性を証明する。
- **言語の垣根の撤廃**: 既存・未来のあらゆる言語の機能を平等に扱える救済手段となる。

---

## ✅ 達成済み
- [x] **並行格子レキサー**: すべての解釈の可能性を網羅する高速な並行スキャン。
- [x] **非決定論的 Packrat パーサー**: 格子状データ（Lattice）を最長一致でバックトラックしながら解析する基盤。
- [x] **明示的空白ハンドリング**: `_S` による透明性の高い構文定義。
- [x] **モジュール化された `init`**: 機能（DNA）を選択的に注入できる言語構成。
- [x] **Z3 ソルバー連携**: `X = 10.5` のような数式制約の解決と推論。
- [x] **汎用ノード (Node) 化**: 固定ASTクラスを廃止し、柔軟なメタ構造へ移行。
- [x] **高精度演算**: `BigDecimal` と Z3 `RealSort` による演算。

---

## 🚀 Phase 1: 意味論と制約エンジンの強化 (Semantics & Solver)
パースされた AST をより高度な論理に結びつけ、「型システムとしてのソルバー」を確立する。
- [ ] **比較演算の追加**: `>`, `<` などの制約を Z3 に流し込む。
- [ ] **条件付き制約 (Guards)**: `if X > 0 then ...` のような、ソルバーの解の状態によって実行を分岐させる。
- [ ] **リファインメント・タイプの実装**: `init` 内で「この変数は偶数である」といった制約を「型」として定義するモジュール。
- [ ] **エラーレポートの高度化**: `UNSAT`（矛盾）発生時、どのソースコードの行が原因かを表示する。

## 🛠️ Phase 2: 万能マクロシステム (Self-Modification)
言語が自己を再定義し、新しい構文を生成する能力を実装する。

- [ ] **Step 2.1: 即時評価器 (Evaluator)**
    - AST を受け取り、即座に計算して値を返すエンジンの実装。
- [ ] **Step 2.2: コンパイル時計算 (Constant Folding)**
    - AST を走査し、定数式を評価結果に置換する最適化モジュール。
- [ ] **Step 2.3: マクロ定義構文とレジストリ**
    - `syntax` 構文のパースと、スコープ付きマクロ管理。
- [ ] **Step 2.4: マクロ展開とリーダーマクロ**
    - パース中の動的ルール追加と、Lexer への介入フック。

## 🌍 Phase 3: 汎用性とポータビリティ (Portability & Performance)
あらゆるプラットフォームへの適応。
- [ ] **ターゲット・トランスパイラ**: AST を C, JavaScript, WASM などへ「蒸留」して出力する機能。
- [ ] **ネイティブコード生成**: LLVM 等を介した直接的な機械語出力。
- [ ] **標準ライブラリカタログ**: `init` から呼び出せる多様な言語パラダイム（Lisp風、C風、Prolog風）の整備。

---

## 📝 直近の作業メモ
1. `Evaluator.scala` の作成。
2. AST (`BinaryOp` 等) の計算ロジックの実装。
3. `X = 1 + 2` を `X = 3` に変換するデモ。