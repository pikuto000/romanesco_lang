# 開発メモ: 構造的書き換えエンジン (Structural Rewriting Engine)

## 背景
初期のパーサー実装では、再帰下降法によるプレフィックス記法のパースのみをサポートしていた。しかし、`x = 1 + 2` のような自然な中置記法（Mixfix）をサポートするため、トークン列を動的に書き換えるエンジンが必要となった。

## アーキテクチャの進化

### 1. トークンベースの書き換え (初期案)
トークン列をフラットなリストとして扱い、パターンマッチングで置換する方式。
- **課題**: `[L] = [R]` のようなマクロにおいて、`R` がどこまでを指すかの境界が曖昧になり、無限ループや誤キャプチャが発生した。

### 2. 構造的書き換え (現在の実装)
トークン列を論理的な「ユニット（Unit）」に分割してからマッチングを行う方式。
- **ユニットの定義**:
    - 括弧 `()` や `{}` で囲まれたバランスの取れたグループ
    - 演算子の項数（Arity）に基づいたプレフィックス適用
    - 単一の識別子や数値
- **利点**:
    - **境界の明確化**: マクロの引数が一つの「完成した式」に限定されるため、隣接する演算子を誤って飲み込むことがない。
    - **無限ループの防止**: キーワードがすでにプレフィックス位置にある場合の適用スキップロジックと組み合わせることで、安定した書き換え（固定点への到達）が可能になった。

## 評価器の非決定性
Python版およびScala版の両方で、評価結果を `List[(Value, Env)]` として返す非決定的評価を実装した。
- `or` 演算子による分岐の探索。
- `unify`（単一化）による制約の解消と環境へのバインディング。

## 暗黙的ビット幅推論 (Z3-based)
Romanescoランタイムは、完全に暗黙的なZ3ベースのビット幅推論システムを採用している。

### 特徴
- **Zero-Syntax Control**: 算術演算子（`+`, `*`等）が自動的にビット幅推論をトリガーする。明示的な型宣言は不要。
- **最適化**:
    - `x + 0`: 幅を維持。
    - `x * 1`: 幅を維持。
    - `x * 0`: 1ビットに短縮。
- **安全なフォールバック**: ビット幅を特定できない場合は無限精度（Z3 Int）として扱い、安全性を確保。
- **グローバル最適化**: `z3.Optimize` を使用し、プログラム全体で制約を満たしつつ最小のビット幅を算出する。

## 実装のパリティ
Python版でのプロトタイピングとデバッグを経て、洗練されたロジックをScala版へ移植した。
- `WidthInference` クラスによる推論の統合。
- `Solver` によるトークンツリーの枝刈りへの推論結果の活用。