# romanesco 言語設計メモ by Gemini

**日付:** 2026-01-16
**概要:** 論理プログラミングと関数型プログラミングの融合。Z3（SMTソルバ）をバックエンドに持ち、「逆写像（制約解消）」を計算の主軸に置く。

---

## 1. コア概念：逆写像としての計算
従来の「入力から出力を構築する」アプローチではなく、**「結果の構造から原因（構成要素）を特定する」**アプローチを採用する。

* **基本動作:** `Cons a b` を作るのではなく、`x = Cons a b` という**等式（制約）**を解くことで、`a` と `b` を単一化（Unify）によって取り出す。
* **バックエンド:** Z3による制約解決として実装。矛盾（UNSAT）した計算枝は消滅し、論理的に整合性のある枝のみが生存する。

---

## 2. パターンマッチと値の抽出
値を抽出する構文について、自己言及の衝突を回避しつつ、論理的に明確な以下の記法を採用する。

### 決定案：論理積による明示的な結合
「構造の分解」と「戻り値の確定」を `and` で接続する。

# 先頭要素を取り出す関数
head = \x -> x = Cons h t and head = h

解説:

構造分解: x = Cons h t によって、未知の変数 h と t が単一化される。

戻り値束縛: head = h によって、抽出された h が関数 head の戻り値として定義される。

利点: 関数名（head）と内部変数（h）が分離されているため、自己言及による衝突が起きない。また、Z3上で「分解」と「返却」が同時に満たされる解のみが探索される。

拡張例：多値返却
# 先頭と残りのペアを返す
split = \x -> (x = Cons h t) and (split = Pair h t)

3. 論理演算と制御構造
分岐や条件を扱うための論理体系。

3つの基本要素（プリミティブ）
複雑さを避け、人間の直感に寄り添うため、以下の3つを第一級の要素とする。

And: 制約の積み上げ（かつ）。

Or: 可能性の分岐（または）。

Not: 満たしてはいけない条件を記述し、探索を剪定する。

中置演算子: マクロシステムにより、中置記法として展開される。

4. 意味論（Semantics）
述語と値
ラムダ式: 明確に「値」を返す唯一の存在。

述語・等号: 値を返すのではなく、**「制約（事実）を追加する」**機能を持つ。

評価戦略
全枝探索: 矛盾しないすべての可能性を探索する。

遅延評価: 具体的な値（Model）の抽出は、観測（Force）が必要になる最期の瞬間まで遅延される。内部では制約のスタックとして扱われる。

5. 今後の実装課題（Scala/Z3）
パーサー: マクロ展開と中置演算子の処理。

評価器:

Keychain（Map）による変数のスコープ管理。

関数定義（head = ...）と制約式（head = h）の内部的な区別。

Z3連携:

論理式をZ3の制約スタックへ変換するロジック。

UNSAT 検知時の枝刈り処理。

---

## 6. 実装の決定事項 (2026-01-16追記)

### 6.1. 文の区切り
*   改行 (`\n`) およびセミコロン (`;`) を文の区切りとして認識する。
*   これにより、`Cons = ...` と `Nil = ...` が同じ行に書かれていない限り、独立した文としてパースされる。

### 6.2. 演算子の優先順位と結合方向
パース時の優先順位（結合の強さ）は以下の通り（下が最も強い）。

1.  `or` (左結合)
2.  `and` (左結合)
3.  `=` (左結合) - *代入・パターンマッチ*
4.  `*`, `/` (左結合) - *乗除算* (※現状の実装では加減算より結合が弱い)
5.  `+`, `-` (左結合) - *加減算* (※現状の実装では比較より結合が弱い)
6.  `==`, `<`, `>`, `<=`, `>=` (左結合) - *比較*
7.  `apply` (関数適用: `f x`) - *スペース区切り*
8.  `lambda` (`\x -> ...`)
9.  `call` (括弧によるグルーピングやアトム)

*   **特記事項:** 関数適用 (`f x`) は二項演算子よりも優先順位が高く、`and` や `=` の引数として誤って吸い込まれることを防ぐため、`isArg` チェックにより演算子やキーワード (`and`, `or`, `=`, `syntax`, `lambda`) を引数として受け入れないように制限している。

### 6.3. `and` と `seq` の役割分担
*   **`and`**: 論理積かつ**ペア（タプル）構築子**として機能する。
    *   `1 and 2` は `(1, 2)` というペア（`PairVal`）を返す。
    *   `true` は恒等元として振る舞い、`true and x` は `x` を返す。
    *   これにより、`Cons = \a -> \b -> a and b` はリスト構造 `(1, (2, ...))` を構築できる。
*   **`seq`**: ブロック `{ s1; s2 }` や改行区切りの文で暗黙的に使用されるシーケンス演算子。
    *   左側の評価結果を捨て（成功時）、右側の評価結果を返す。
    *   副作用（環境への変数の束縛など）は伝播する。

### 6.4. 環境の伝播
*   `Evaluator` は式を評価する際、**更新された環境**を返すようにリファクタリングされた。
*   これにより、`x = Cons first rest and head = first` のような式において、左辺の `x = ...` で束縛された `first` 変数が、右辺の `head = first` で正しく参照可能となる。
