Active code page: 65001
[info] welcome to sbt 1.12.1 (Oracle Corporation Java 25.0.2)
[info] loading project definition from C:\Users\Cocoa\romanesco\project\project\project
[info] loading settings for project romanesco-build-build from metals.sbt...
[info] loading project definition from C:\Users\Cocoa\romanesco\project\project
[info] loading settings for project romanesco-build from metals.sbt, plugins.sbt...
[info] loading project definition from C:\Users\Cocoa\romanesco\project
[info] loading settings for project root from build.sbt...
[info] set current project to romanesco (in build file:/C:/Users/Cocoa/romanesco/)
[info] running romanesco.Solver.SolverTests.CycleTest 
[DEBUG] logger disabled
=== Cycle Detection Test ===
Testing simple loop: P(a)
[DEBUG] Max log depth set to 3
Failed as expected: No proof found
Testing loop with Forall: 竏(x,P(x))
[DEBUG] Max log depth set to 3
Failed: No proof found
Testing complex loop: P(a) -> Q(a) -> P(a)
[DEBUG] Max log depth set to 3
Failed: No proof found
Testing growth loop: P(a) -> P(f(a))
[DEBUG] Max log depth set to 3
Failed: No proof found
[success] Total time: 2 s, completed 2026/02/13 14:22:41
[info] running romanesco.Solver.SolverTests.CycleTest2 
[DEBUG] logger disabled
=== Cycle Detection Test 2 (Inner Branch) ===
Testing loop: P(a)
[DEBUG] Max log depth set to 3
[success] Total time: 0 s, completed 2026/02/13 14:22:42
[info] running romanesco.Solver.SolverTests.DebugAssoc 
[DEBUG] logger disabled
[DEBUG] Max log depth set to 10
=== Debug: Path Associativity ===
[DEBUG] Max log depth set to 3
笨・Solved!
              笨・竓､  {true-intro}
            笏披楳 竏(r,path(A,z_2,w_3),竓､)  {forall-intro}
          笏披楳 竏(q,path(A,y_1,z_2),竏(r,path(A,z_2,w_3),竓､))  {forall-intro}
        笏披楳 竏(p,path(A,x_0,y_1),竏(q,path(A,y_1,z_2),竏(r,path(A,z_2,w_3),竓､)))  {forall-intro}
      笏披楳 竏(w,竏(p,path(A,x_0,y_1),竏(q,path(A,y_1,z_2),竏(r,path(A,z_2,w),竓､))))  {forall-intro}
    笏披楳 竏(z,竏(w,竏(p,path(A,x_0,y_1),竏(q,path(A,y_1,z),竏(r,path(A,z,w),竓､)))))  {forall-intro}
  笏披楳 竏(y,竏(z,竏(w,竏(p,path(A,x_0,y),竏(q,path(A,y,z),竏(r,path(A,z,w),竓､))))))  {forall-intro}
笏披楳 竏(x,竏(y,竏(z,竏(w,竏(p,path(A,x,y),竏(q,path(A,y,z),竏(r,path(A,z,w),竓､)))))))  {forall-intro}
[success] Total time: 2 s, completed 2026/02/13 14:22:44
[info] running romanesco.Solver.SolverTests.DebugLinear 
[DEBUG] logger disabled
=== Debug: A 竓ｸ B 竓ｸ (A 竓・B) ===
[DEBUG] Max log depth set to 3
笨・Solved!
      笨・A  {linear:lh0}
    笏披楳 竓・A,B)  {cancel[lh1]}
  笏披楳 竓ｸ(B,竓・A,B))  {linear-implies-intro}
笏披楳 竓ｸ(A,竓ｸ(B,竓・A,B)))  {linear-implies-intro}
[success] Total time: 0 s, completed 2026/02/13 14:22:45
[info] running romanesco.Solver.SolverTests.HoTTCubeTest 
[DEBUG] logger disabled
=== HoTT: Cubical Model Approximation Test ===
Case: cube(A, p, q, r, s) 竊・path(path(A, x, y), p, r) ... [DEBUG] Max log depth set to 3
笨・OK (Solved)
Case: cube(A, p, q, r, s) 竊・path(path(A, x, z), q, s) ... [DEBUG] Max log depth set to 3
笨・OK (Failed as expected)
[success] Total time: 1 s, completed 2026/02/13 14:22:45
[info] running romanesco.Solver.SolverTests.HoTTTest 
[DEBUG] logger disabled
=== HoTT: Path Induction and HIT Test ===
Case: 竏x. 竏y. 竏p:path(A,x,y). concat(p, refl(y)) = p ... [DEBUG] Max log depth set to 3
笨・OK (Solved)
Case: 竏x. 竏y. 竏p:path(A,x,y). concat(refl(x), p) = p ... [DEBUG] Max log depth set to 3
笨・OK (Solved)
Case: 竏x. 竏y. 竏z. 竏w. 竏p:path(A,x,y). 竏q:path(A,y,z). 竏r:path(A,z,w). concat(concat(p, q), r) = concat(p, concat(q, r)) ... [DEBUG] Max log depth set to 3
笨・OK (Solved)
Case: 竏x. 竏y. 竏p:path(A,x,y). inv(inv(p)) = p ... [DEBUG] Max log depth set to 3
笨・OK (Solved)
Case: 竏x:S1. P(base) 竊・P(x) ... [DEBUG] Max log depth set to 3
笨・OK (Solved)
Case: equiv(A, B) 竊・path(Type, A, B) ... [DEBUG] Max log depth set to 3
笨・OK (Solved)
[success] Total time: 3 s, completed 2026/02/13 14:22:48
[info] running romanesco.Solver.SolverTests.LinearResourceTest 
[DEBUG] logger disabled
=== Linear Logic: Resource Consumption Test ===
Case: A 竓ｸ A ... [DEBUG] Max log depth set to 3
笨・OK (Solved as expected)
Case: (A 竓・B) 竓ｸ (B 竓・A) ... [DEBUG] Max log depth set to 3
笨・OK (Solved as expected)
Case: A 竓ｸ (A 竓・A) ... [DEBUG] Max log depth set to 3
笨・OK (Failed as expected)
Case: A 竓ｸ B 竓ｸ (A 竓・B) ... [DEBUG] Max log depth set to 3
笨・OK (Solved as expected)
Case: (A 竓・A) 竓ｸ A ... [DEBUG] Max log depth set to 3
笨・OK (Failed as expected)
[success] Total time: 0 s, completed 2026/02/13 14:22:48
[info] running romanesco.Solver.SolverTests.SeparationLogicTest 
[DEBUG] logger disabled
=== Separation Logic: Resource Management Test ===
Case: A * B 竓ｸ B * A (depth 10) ... [DEBUG] Max log depth set to 3
笨・OK (Solved)
Case: (A * B) * C 竓ｸ A * (B * C) (depth 10) ... [DEBUG] Max log depth set to 3
笨・OK (Solved)
Case: (A 竓ｸ B) 竓ｸ (A * C 竓ｸ B * C) (depth 15) ... [DEBUG] Max log depth set to 3
笨・OK (Solved)
Case: A * A 竓ｸ A (depth 5) ... [DEBUG] Max log depth set to 3
笨・OK (Failed as expected)
Case: A 竓ｸ A * A (depth 5) ... [DEBUG] Max log depth set to 3
笨・OK (Failed as expected)
Case: (竏v. (x 竊ｦ v 竓ｸ P(v))) 竓ｸ (x 竊ｦ 5 竓ｸ P(5)) (depth 8) ... [DEBUG] Max log depth set to 3
笨・OK (Solved)
Case: A * B * C 竓ｸ C * A * B (depth 8) ... [DEBUG] Max log depth set to 3
笨・OK (Solved)
Case: (竏v. (x 竊ｦ v * R)) 竓ｸ (x 竊ｦ 5 * R) (depth 8) ... [DEBUG] Max log depth set to 3
笨・OK (Solved)
[success] Total time: 1 s, completed 2026/02/13 14:22:49
[info] running romanesco.Solver.SolverTests.TemporalLogicTest 
[DEBUG] logger disabled
=== Temporal Logic: Co-induction Test ===
Case: G(A) 竊・A ... [DEBUG] Max log depth set to 3
笨・OK (Solved)
Case: G(A) 竊・X(A) ... [DEBUG] Max log depth set to 3
笨・OK (Solved)
Case: G(A) 竊・G(G(A)) ... [DEBUG] Max log depth set to 3
笨・OK (Solved)
Case: G(A 竊・B) 竊・G(A) 竊・G(B) ... [DEBUG] Max log depth set to 3
笨・OK (Solved)
[success] Total time: 0 s, completed 2026/02/13 14:22:49
[info] running romanesco.Solver.SolverTests.TypeLevelTest 
[DEBUG] logger disabled
=== Strict Universe Level Unification Test ===
Proving: Type0 = Type0 ...
[DEBUG] Max log depth set to 3
笨・OK (Solved)
Proving: Type0 = Type1 ...
[DEBUG] Max log depth set to 3
笨・OK (Failed as expected)
[success] Total time: 0 s, completed 2026/02/13 14:22:50
[info] running romanesco.Solver.testGeneralizedUnification 
[DEBUG] logger disabled
=== Generalized Higher-Order Unification Test ===

Test 1: ?P(f(x)) = g(f(x))
Unifying: ?1(f(x)) = g(f(x))
笨・Solutions found:
  Solution 0:
    ?1 -> ﾎｻv_0. g(v_0)
    Check: g(f(x)) == g(f(x))
    笨・Valid

Test 2: ?P(a, b) = f(b, a)
Unifying: ?1(a,b) = f(b,a)
笨・Solutions found:
  Solution 0:
    ?1 -> ﾎｻv_0. ﾎｻv_1. f(v_1,v_0)
    Check: f(b,a) == f(b,a)
    笨・Valid

Test 3: ?P(S(x), x) = S(S(x))
Unifying: ?1(S(x),x) = S(S(x))
笨・Solutions found:
  Solution 0:
    ?1 -> ﾎｻv_0. ﾎｻv_1. S(v_0)
    Check: S(S(x)) == S(S(x))
    笨・Valid
[success] Total time: 0 s, completed 2026/02/13 14:22:50
[info] running romanesco.Solver.testLinearLogic 
[DEBUG] logger disabled
=== Linear Logic Test (Mapping Approach) ===

[Test Case] A 竓ｸ A
[DEBUG] Max log depth set to 3
笨・Solved:
    笨・A  {linear:lh0}
  笏披楳 竓ｸ(A,A)  {linear-implies-intro}

[Test Case] (A 竓・B) 竓ｸ (A 竓・B)
[DEBUG] Max log depth set to 3
笨・Solved:
    笨・竓・A,B)  {linear:lh0}
  笏披楳 竓ｸ(竓・A,B),竓・A,B))  {linear-implies-intro}

[Test Case] !A 竊・A
[DEBUG] Max log depth set to 3
笨・Solved:
      笨・A  {h0}
    笏披楳 A  {linear-bang-elim[h0]}
  笏披楳 竊・!(A),A)  {implies-intro}

[Test Case] A 竓・B 竊・A 竏ｧ B
[DEBUG] Max log depth set to 3
笨・Solved:
        笨・ﾃ・A,B)  {h0}
      笏披楳 ﾃ・A,B)  {tensor-is-ﾃ夕h0]}
    笏披楳 竏ｧ(A,B)  {and-is-ﾃ抑
  笏披楳 竊・竓・A,B),竏ｧ(A,B))  {implies-intro}
[success] Total time: 0 s, completed 2026/02/13 14:22:50
[info] running romanesco.Solver.testMapFusion 
[DEBUG] logger disabled
=== Map Fusion Test ===
Goal: 竏f. 竏g. 竏xs. map(f, map(g, xs)) = map(f 竏・g, xs)
[DEBUG] Max log depth set to 3
笨・Proof found:
              笨・竓､  {true-intro}
            笏披楳 map(f_0,nil) = nil  {map_nil}
          笏披楳 map(f_0,map(g_1,nil)) = nil  {map_nil}
        笏披楳 map(f_0,map(g_1,nil)) = map(竏・f_0,g_1),nil)  {map_nil}
                  笨・竓､  {true-intro}
                笏披楳 cons(f_0(g_1(a_0)),map(f_0,map(g_1,xs_1))) = cons(f_0(g_1(a_0)),map(竏・f_0,g_1),xs_1))  {rewrite[IH_xs_1]}
              笏披楳 cons(f_0(g_1(a_0)),map(f_0,map(g_1,xs_1))) = cons(竏・f_0,g_1)(a_0),map(竏・f_0,g_1),xs_1))  {compose_app}
            笏披楳 cons(f_0(g_1(a_0)),map(f_0,map(g_1,xs_1))) = map(竏・f_0,g_1),cons(a_0,xs_1))  {map_cons}
          笏披楳 map(f_0,cons(g_1(a_0),map(g_1,xs_1))) = map(竏・f_0,g_1),cons(a_0,xs_1))  {map_cons}
        笏披楳 map(f_0,map(g_1,cons(a_0,xs_1))) = map(竏・f_0,g_1),cons(a_0,xs_1))  {map_cons}
      笏披楳 竏(xs,map(f_0,map(g_1,xs)) = map(竏・f_0,g_1),xs))  {induction[List]}
    笏披楳 竏(g,竏(xs,map(f_0,map(g,xs)) = map(竏・f_0,g),xs)))  {forall-intro}
  笏披楳 竏(f,竏(g,竏(xs,map(f,map(g,xs)) = map(竏・f,g),xs))))  {forall-intro}
[success] Total time: 2 s, completed 2026/02/13 14:22:52
[info] running romanesco.Solver.testModalLogic 
[DEBUG] logger disabled
=== Modal Logic Test ===
[Test Case] 笆｡(A 竊・B) 竊・(笆｡A 竊・笆｡B)
[DEBUG] Max log depth set to 3
笨・Solved:      笨・笆｡(竊・A,B))  {h0}
    笏披楳 竊・笆｡(A),笆｡(B))  {modal-K}
  笏披楳 竊・笆｡(竊・A,B)),竊・笆｡(A),笆｡(B)))  {implies-intro}
[Test Case] 笆｡A 竊・A
[DEBUG] Max log depth set to 3
笨・Solved:      笨・A  {h0}
    笏披楳 A  {modal-T[h0]}
  笏披楳 竊・笆｡(A),A)  {implies-intro}
[Test Case] 笆｡A 竊・笆｡笆｡A
[DEBUG] Max log depth set to 3
笨・Solved:      笨・笆｡(笆｡(A))  {h0}
    笏披楳 笆｡(笆｡(A))  {modal-4[h0]}
  笏披楳 竊・笆｡(A),笆｡(笆｡(A)))  {implies-intro}
[Test Case] 笳② 竊・笆｡笳②
[DEBUG] Max log depth set to 3
笨・Solved:      笨・笆｡(笳・A))  {h0}
    笏披楳 笆｡(笳・A))  {modal-5[h0]}
  笏披楳 竊・笳・A),笆｡(笳・A)))  {implies-intro}
[Test Case] 笳② 竊・(笆｡(A 竊・竓･) 竊・竓･)
[DEBUG] Max log depth set to 3
笨・Solved:      笨・竊・笆｡(竊・A,竓･)),竓･)  {h0}
    笏披楳 竊・笆｡(竊・A,竓･)),竓･)  {modal-duality[h0]}
  笏披楳 竊・笳・A),竊・笆｡(竊・A,竓･)),竓･))  {implies-intro}
[success] Total time: 1 s, completed 2026/02/13 14:22:53
[info] running romanesco.Solver.testPatternUnification 
[DEBUG] logger disabled
=== Pattern Unification Test ===
Test 1: ?P(x) = x = 0
Unifying: ?1(x) = x = 0
笨・Solutions found:
  Solution 0:
    ?1 -> ﾎｻv_0. v_0 = 0
    Applied LHS: x = 0
    Normalized:  x = 0
    笨・Valid solution

Test 2: ?M(x) = S(x)
Unifying: ?2(x) = S(x)
  Solution: ﾎｻv_0. S(v_0)
[success] Total time: 0 s, completed 2026/02/13 14:22:53
[info] running romanesco.Solver.testTactics 
=== Tactic System Test ===
Initial state:
--------------------------------

--------------------------------
  Goal: 竊・竏ｧ(A,B),竏ｧ(B,A))

After intro:
--------------------------------
  h0: 竏ｧ(A,B)
--------------------------------
  Goal: 竏ｧ(B,A)

After destruct h0:
--------------------------------
  h0.1: A
  h0.2: B
--------------------------------
  Goal: 竏ｧ(B,A)

After split (Subgoal 1):
--------------------------------
  h0.1: A
  h0.2: B
--------------------------------
  Goal: B

After solve B (Subgoal 2):
--------------------------------
  h0.1: A
  h0.2: B
--------------------------------
  Goal: A

笨・Goal solved successfully using tactics!

=== Auto Tactic Test: A 竏ｧ B 竊・B 竏ｧ A ===

After intro, calling auto on goal: --------------------------------
  h0: 竏ｧ(A,B)
--------------------------------
  Goal: 竏ｧ(B,A)
[DEBUG] Max log depth set to 3
笨・Auto solved: 笨・竏ｧ(A,B)  {h0}

笨・Auto tactic solved the goal with context!

=== Simpl Tactic Test: plus(0, n) = n ===

After intro:
--------------------------------

--------------------------------
  Goal: plus(0,n_t1) = n_t1

After simpl:
--------------------------------

--------------------------------
  Goal: 竓､

笨・Simpl tactic error: reflexivity: Goal is not an equality

=== Induction Test: plus(n, 0) = n ===

Base Case:
--------------------------------

--------------------------------
  Goal: plus(0,0) = 0

Inductive Step:
--------------------------------

--------------------------------
  Goal: 竏(n,竊・plus(n,0) = n,plus(S(n),0) = S(n)))

Base Case solved! Next goal:
--------------------------------

--------------------------------
  Goal: 竏(n,竊・plus(n,0) = n,plus(S(n),0) = S(n)))

After intro n:
--------------------------------

--------------------------------
  Goal: 竊・plus(n_t1,0) = n_t1,plus(S(n_t1),0) = S(n_t1))

After intro IH:
--------------------------------
  IH: plus(n_t1,0) = n_t1
--------------------------------
  Goal: plus(S(n_t1),0) = S(n_t1)

笨・Tactic error: rewrite: Hypothesis 'IH' not applicable to goal
[success] Total time: 0 s, completed 2026/02/13 14:22:54
[info] running romanesco.Solver.testTreeInduction 
[DEBUG] logger disabled
=== Tree Induction Test ===
Goal: 竏t. reverse(reverse(t)) = t
[DEBUG] Max log depth set to 3
笨・Proof found:
        笨・竓､  {true-intro}
      笏披楳 reverse(leaf) = leaf  {reverse_leaf}
    笏披楳 reverse(reverse(leaf)) = leaf  {reverse_leaf}
            笨・竓､  {true-intro}
          笏披楳 node(t_0,a_1,reverse(reverse(t_2))) = node(t_0,a_1,t_2)  {rewrite[IH_t_2]}
        笏披楳 node(reverse(reverse(t_0)),a_1,reverse(reverse(t_2))) = node(t_0,a_1,t_2)  {rewrite[IH_t_0]}
      笏披楳 reverse(node(reverse(t_2),a_1,reverse(t_0))) = node(t_0,a_1,t_2)  {reverse_node}
    笏披楳 reverse(reverse(node(t_0,a_1,t_2))) = node(t_0,a_1,t_2)  {reverse_node}
  笏披楳 竏(t,reverse(reverse(t)) = t)  {induction[Tree]}
[success] Total time: 1 s, completed 2026/02/13 14:22:54
[info] running romanesco.Solver.SolverTests.RecursiveInductionTest 
[DEBUG] logger disabled
=== Recursive Data Structure Induction Test ===
Case: 竏xs. append(xs, nil) = xs ... [DEBUG] Max log depth set to 3
笨・OK
Case: 竏xs. 竏ys. 竏zs. append(append(xs, ys), zs) = append(xs, append(ys, zs)) ... [DEBUG] Max log depth set to 3
笨・OK
Case: 竏t. mirror(mirror(t)) = t ... [DEBUG] Max log depth set to 3
笨・OK
  (Induction used)
Case: 竏xs. 竏ys. list_prop(append(xs, ys)) ... [DEBUG] Max log depth set to 3
笨・OK
  (Induction used)
[success] Total time: 1 s, completed 2026/02/13 14:22:55
[info] running romanesco.testSomeCases 
[DEBUG] logger disabled

=== Induction Test: plus(n, S(m)) = S(plus(n, m)) ===

Base Case solved! Next goal:
Goals:
  0: --------------------------------

--------------------------------
  Goal: 竏(n,竊・竏(m,plus(n,S(m)) = S(plus(n,m))),竏(m,plus(S(n),S(m)) = S(plus(S(n),m)))))

After intros:
Goals:
  0: --------------------------------
  IH: 竏(m,plus(n_step,S(m)) = S(plus(n_step,m)))
--------------------------------
  Goal: plus(S(n_step),S(m)) = S(plus(S(n_step),m))
笨・Error in manual induction: Rewrite IH failed

=== Automatic Induction Tests ===

[Test Case] 竏n. plus(n, 0) = n
[DEBUG] Max log depth set to 3
笨・Solved:
    笨・竓､  {true-intro}
  笏披楳 竏(n,竓､)  {forall-intro}

[Test Case] 竏n. plus(0, n) = n
[DEBUG] Max log depth set to 3
笨・Solved:
    笨・竓､  {true-intro}
  笏披楳 竏(n,竓､)  {forall-intro}

[Test Case] 竏n. 竏m. plus(n, S(m)) = S(plus(n, m))
[DEBUG] Max log depth set to 3
笨・Solved:
      笨・竓､  {true-intro}
    笏披楳 竏(m,竓､)  {forall-intro}
  笏披楳 竏(n,竏(m,竓､))  {forall-intro}

[Test Case] 竏xs. append(xs, nil) = xs
[DEBUG] Max log depth set to 3
笨・Solved:
    笨・竓､  {true-intro}
  笏披楳 竏(xs,竓､)  {forall-intro}

[Test Case] 竏xs. append(nil, xs) = xs
[DEBUG] Max log depth set to 3
笨・Solved:
    笨・竓､  {true-intro}
  笏披楳 竏(xs,竓､)  {forall-intro}

[Test Case] 竏xs. 竏ys. 竏zs. append(append(xs, ys), zs) = append(xs, append(ys, zs))
[DEBUG] Max log depth set to 3
笨・Solved:
        笨・竓､  {true-intro}
      笏披楳 竏(zs,竓､)  {forall-intro}
    笏披楳 竏(ys,竏(zs,竓､))  {forall-intro}
  笏披楳 竏(xs,竏(ys,竏(zs,竓､)))  {forall-intro}

[Test Case] 竏n. 竏m. plus(n, m) = plus(m, n)
[DEBUG] Max log depth set to 3
笨・Solved:
      笨・竓､  {true-intro}
    笏披楳 竏(m,竓､)  {forall-intro}
  笏披楳 竏(n,竏(m,竓､))  {forall-intro}

[Test Case] 竏n. 竏m. 竏k. plus(plus(n, m), k) = plus(n, plus(m, k))
[DEBUG] Max log depth set to 3
笨・Solved:
        笨・竓､  {true-intro}
      笏披楳 竏(k,竓､)  {forall-intro}
    笏披楳 竏(m,竏(k,竓､))  {forall-intro}
  笏披楳 竏(n,竏(m,竏(k,竓､)))  {forall-intro}
[success] Total time: 0 s, completed 2026/02/13 14:22:55
[info] running romanesco.Solver.SolverTests.CombinedLogicTest 
=== Combined Multi-Logic Test ===

[Test Case] G(A 竓ｸ B) 竊・(G(A) 竓ｸ G(B))
[DEBUG] Max log depth set to 3
笨・Solved!
      笨・竓ｸ(G(A),G(B))  {h0}
    笏披楳 竓ｸ(G(A),G(B))  {G-dist-limplies[h0]}
  笏披楳 竊・G(竓ｸ(A,B)),竓ｸ(G(A),G(B)))  {implies-intro}

[Test Case] 笆｡(A 竓ｸ B) 竊・(笆｡A 竓ｸ 笆｡B)
[DEBUG] Max log depth set to 3
笨・Solved!
      笨・竓ｸ(笆｡(A),笆｡(B))  {h0}
    笏披楳 竓ｸ(笆｡(A),笆｡(B))  {modal-K-linear[h0]}
  笏披楳 竊・笆｡(竓ｸ(A,B)),竓ｸ(笆｡(A),笆｡(B)))  {implies-intro}

[Test Case] G(A * B) 竓ｸ (G(A) * G(B))
[DEBUG] Max log depth set to 3
笨・Solved!
      笨・*(G(A),G(B))  {linear:lh0}
    笏披楳 *(G(A),G(B))  {G-dist-sepand[lh0]}
  笏披楳 竓ｸ(G(*(A,B)),*(G(A),G(B)))  {linear-implies-intro}

[Test Case] 笆｡G(A 竓ｸ B) 竊・G(笆｡A 竓ｸ 笆｡B)
[DEBUG] Max log depth set to 3
笨・Solved!
          笨・G(竓ｸ(A,B))  {h0}
        笏披楳 G(笆｡(竓ｸ(A,B)))  {modal-T}
      笏披楳 G(竓ｸ(笆｡(A),笆｡(B)))  {modal-K-linear}
    笏披楳 G(竓ｸ(笆｡(A),笆｡(B)))  {modal-T[h0]}
  笏披楳 竊・笆｡(G(竓ｸ(A,B))),G(竓ｸ(笆｡(A),笆｡(B))))  {implies-intro}

[Test Case] 笆｡(A * B) 竊・(笆｡A * 笆｡B)
[DEBUG] Max log depth set to 3
笨・Solved!
          笨・*(A,B)  {h0}
        笏披楳 *(B,笆｡(A))  {modal-T}
      笏披楳 *(B,笆｡(A))  {modal-T[h0]}
    笏披楳 *(笆｡(A),笆｡(B))  {modal-T}
  笏披楳 竊・笆｡(*(A,B)),*(笆｡(A),笆｡(B)))  {implies-intro}

[Test Case] G(竏x. A(x) 竓ｸ B(x)) 竊・竏x. (G(A(x)) 竓ｸ G(B(x)))
[DEBUG] Max log depth set to 3
笨・Solved!
                笨・G(竓ｸ(A(x_1),B(x_1)))  {co-induction}
              笏披楳 G(竓ｸ(A(x_1),B(x_1)))  {plus_0}
            笏披楳 X(G(竓ｸ(A(x_1),B(x_1))))  {next-step}
            笨・竓ｸ(A(x_1),B(x_1))  {h0}
          笏披楳 竏ｧ(X(G(竓ｸ(A(x_1),B(x_1)))),竓ｸ(A(x_1),B(x_1)))  {product-intro}
        笏披楳 G(竓ｸ(A(x_1),B(x_1)))  {G-expansion}
      笏披楳 竓ｸ(G(A(x_1)),G(B(x_1)))  {G-dist-limplies}
    笏披楳 竏(x,竓ｸ(G(A(x)),G(B(x))))  {forall-intro}
  笏披楳 竊・G(竏(x,竓ｸ(A(x),B(x)))),竏(x,竓ｸ(G(A(x)),G(B(x)))))  {implies-intro}

[Test Case] 竏x. 笆｡(P(x) 竓ｸ Q(x)) 竊・竏x. (笆｡P(x) 竓ｸ 笆｡Q(x))
[DEBUG] Max log depth set to 3
笨・Solved!
          笨・笆｡(竓ｸ(P(x_0_2),Q(x_0_2)))  {h1}
        笏披楳 竓ｸ(笆｡(P(x_0_2)),笆｡(Q(x_0_2)))  {modal-K-linear}
      笏披楳 竏(x_0,竓ｸ(笆｡(P(x_0)),笆｡(Q(x_0))))  {forall-intro}
    笏披楳 竊・笆｡(竓ｸ(P(x_0),Q(x_0))),竏(x_0,竓ｸ(笆｡(P(x_0)),笆｡(Q(x_0)))))  {implies-intro}
  笏披楳 竏(x,竊・笆｡(竓ｸ(P(x),Q(x))),竏(x,竓ｸ(笆｡(P(x)),笆｡(Q(x))))))  {forall-intro}
[success] Total time: 17 s, completed 2026/02/13 14:23:13
