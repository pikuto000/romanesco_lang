Active code page: 65001
[info] welcome to sbt 1.12.1 (Oracle Corporation Java 25.0.2)
[info] loading project definition from C:\Users\Cocoa\romanesco\project\project\project
[info] loading settings for project romanesco-build-build from metals.sbt...
[info] loading project definition from C:\Users\Cocoa\romanesco\project\project
[info] loading settings for project romanesco-build from metals.sbt, plugins.sbt...
[info] loading project definition from C:\Users\Cocoa\romanesco\project
[info] loading settings for project root from build.sbt...
[info] set current project to romanesco (in build file:/C:/Users/Cocoa/romanesco/)
[info] running romanesco.Solver.SolverTests.CycleTest 
[LOGGER] DISABLED
=== Cycle Detection Test ===
Testing simple loop: P(a)
Failed as expected: No proof found
Testing loop with Forall: ∀(x,P(x))
Failed as expected: No proof found
Testing complex loop: P(a) -> Q(a) -> P(a)
Failed as expected: No proof found
Testing growth loop: P(a) -> P(f(a))
Failed as expected: No proof found
[success] Total time: 3 s, completed 2026/02/19 3:54:25
[info] running romanesco.Solver.SolverTests.CycleTest2 
[LOGGER] DISABLED
=== Cycle Detection Test 2 (Inner Branch) ===
Testing loop: P(a)
[success] Total time: 0 s, completed 2026/02/19 3:54:26
[info] running romanesco.Solver.SolverTests.DebugAssoc 
[LOGGER] DISABLED
[LOGGER] Max log depth set to 10
=== Debug: Path Associativity ===
✓ Solved!
            ✓ path(A,x_0,y_1)  {p_4}
          └─ ∀(q,path(A,y_1,z_2),∀(r,path(A,z_2,w_3),⊤))  {rewrite[p_4]}
        └─ ∀(p,path(A,x_0,y_1),∀(q,path(A,y_1,z_2),∀(r,path(A,z_2,w_3),⊤)))  {forall-intro}
      └─ ∀(w,∀(p,path(A,x_0,y_1),∀(q,path(A,y_1,z_2),∀(r,path(A,z_2,w),⊤))))  {forall-intro}
    └─ ∀(z,∀(w,∀(p,path(A,x_0,y_1),∀(q,path(A,y_1,z),∀(r,path(A,z,w),⊤)))))  {forall-intro}
  └─ ∀(y,∀(z,∀(w,∀(p,path(A,x_0,y),∀(q,path(A,y,z),∀(r,path(A,z,w),⊤))))))  {forall-intro}
└─ ∀(x,∀(y,∀(z,∀(w,∀(p,path(A,x,y),∀(q,path(A,y,z),∀(r,path(A,z,w),⊤)))))))  {forall-intro}
[success] Total time: 13 s, completed 2026/02/19 3:54:39
[info] running romanesco.Solver.SolverTests.DebugLinear 
[LOGGER] DISABLED
=== Debug: A ⊸ B ⊸ (A ⊗ B) ===
✓ Solved!
      ✓ A  {lh0}
      ✓ B  {lh1}
    └─ ⊗(A,B)  {tensor-intro}
  └─ ⊸(B,⊗(A,B))  {linear-implies-intro}
└─ ⊸(A,⊸(B,⊗(A,B)))  {linear-implies-intro}
[success] Total time: 0 s, completed 2026/02/19 3:54:39
[info] running romanesco.Solver.SolverTests.HoTTCubeTest 
[LOGGER] DISABLED
=== HoTT: Cubical Model Approximation Test ===
Case: cube(A, p, q, r, s) → path(path(A, x, y), p, r) ... ✓ OK (Solved)
Case: cube(A, p, q, r, s) → path(path(A, x, z), q, s) ... ✓ OK (Solved)
[success] Total time: 1 s, completed 2026/02/19 3:54:40
[info] running romanesco.Solver.SolverTests.HoTTTest 
[LOGGER] DISABLED
=== HoTT: Path Induction and HIT Test ===
Case: ∀x. ∀y. ∀p:path(A,x,y). concat(p, refl(y)) = p ... ✓ OK (Solved)
Case: ∀x. ∀y. ∀p:path(A,x,y). concat(refl(x), p) = p ... ✓ OK (Solved)
Case: ∀x. ∀y. ∀z. ∀w. ∀p:path(A,x,y). ∀q:path(A,y,z). ∀r:path(A,z,w). concat(concat(p, q), r) = concat(p, concat(q, r)) ... ✓ OK (Solved)
Case: ∀x. ∀y. ∀p:path(A,x,y). inv(inv(p)) = p ... ✓ OK (Solved)
Case: ∀x:S1. P(base) → P(x) ... ✓ OK (Solved)
Case: equiv(A, B) → path(Type, A, B) ... ✓ OK (Solved)
[success] Total time: 14 s, completed 2026/02/19 3:54:54
[info] running romanesco.Solver.SolverTests.LinearResourceTest 
[LOGGER] DISABLED
=== Linear Logic: Resource Consumption Test ===
Case: A ⊸ A ... ✓ OK (Solved as expected)
Case: (A ⊗ B) ⊸ (B ⊗ A) ... ✓ OK (Solved as expected)
Case: A ⊸ (A ⊗ A) ... ✓ OK (Failed as expected)
Case: A ⊸ B ⊸ (A ⊗ B) ... ✓ OK (Solved as expected)
Case: (A ⊗ A) ⊸ A ... ✓ OK (Failed as expected)
[success] Total time: 0 s, completed 2026/02/19 3:54:54
[info] running romanesco.Solver.SolverTests.SeparationLogicTest 
[LOGGER] DISABLED
=== Separation Logic: Resource Management Test ===
Case: A * B ⊸ B * A (depth 10) ... ✓ OK (Solved)
Case: (A * B) * C ⊸ A * (B * C) (depth 10) ... ✓ OK (Solved)
Case: (A ⊸ B) ⊸ (A * C ⊸ B * C) (depth 15) ... ✓ OK (Solved)
Case: (A * A) ⊸ A (depth 5) ... ✓ OK (Failed as expected)
Case: (A ⊸ A) * A (depth 5) ... ✓ OK (Failed as expected)
Case: (∀v. (x ↦ v ⊸ P(v))) ⊸ (x ↦ 5 ⊸ P(5)) (depth 8) ... ✓ OK (Solved)
Case: A * B * C ⊸ C * A * B (depth 8) ... ✓ OK (Solved)
Case: (∀v. (x ↦ v * R)) ⊸ (x ↦ 5 * R) (depth 8) ... ✓ OK (Solved)
Case: ∃F. (A * B ⊸ A * F) (depth 10) ... ✓ OK (Solved)
Case: ∃F. (x ↦ 1 * y ↦ 2 ⊸ x ↦ 1 * F) (depth 10) ... ✓ OK (Solved)
Case: ∃F. (A * B * C ⊸ B * F) (depth 10) ... ✓ OK (Solved)
[success] Total time: 1 s, completed 2026/02/19 3:54:55
[info] running romanesco.Solver.SolverTests.TemporalLogicTest 
[LOGGER] DISABLED
=== Temporal Logic: Co-induction Test ===
Case: G(A) → A ... ✓ OK (Solved)
Case: G(A) → X(A) ... ✓ OK (Solved)
Case: G(A) → G(G(A)) ... ✓ OK (Solved)
Case: G(A → B) → G(A) → G(B) ... ✓ OK (Solved)
[success] Total time: 1 s, completed 2026/02/19 3:54:56
[info] running romanesco.Solver.SolverTests.TypeLevelTest 
[LOGGER] DISABLED
=== Strict Universe Level Unification Test ===
Proving: Type0 = Type0 ...
✓ OK (Solved)
Proving: Type0 = Type1 ...
✓ OK (Failed as expected)
[success] Total time: 0 s, completed 2026/02/19 3:54:56
[info] running romanesco.Solver.SolverTests.HoareLogicTest 
[LOGGER] DISABLED
=== Hoare Logic: Program Verification Test ===
Case: {x = 1} skip {x = 1} ... ✁EOK (Solved)
Case: {⊤} x := 1 {x = 1} ... ✁EOK (Solved)
Case: {⊤} x := 1 ; y := 2 {x = 1 ∧ y = 2} ... ✁EOK (Solved)
Case: {⊤} if (x = 0) x := 1 else x := 2 {x = 1 ∨ x = 2} ... ✁EOK (Solved)
Case: {x = 0} while [x = 0 ∨ x = 1] (x = 0) x := 1 {x = 1} ... ✁EOK (Solved)
[success] Total time: 6 s, completed 2026/02/19 3:55:03
[info] running romanesco.Solver.testGeneralizedUnification 
[LOGGER] DISABLED
=== Generalized Higher-Order Unification Test ===

Test 1: ?P(f(x)) = g(f(x))
Unifying: ?1(f(x)) = g(f(x))
✓ Solutions found:
  Solution 0:
    ?1 -> λbv0. g(bv0)
    Check: g(f(x)) == g(f(x))
    ✓ Valid

Test 2: ?P(a, b) = f(b, a)
Unifying: ?1(a,b) = f(b,a)
✓ Solutions found:
  Solution 0:
    ?1 -> λbv0. λbv1. f(bv1,bv0)
    Check: f(b,a) == f(b,a)
    ✓ Valid

Test 3: ?P(S(x), x) = S(S(x))
Unifying: ?1(S(x),x) = S(S(x))
✓ Solutions found:
  Solution 0:
    ?1 -> λbv0. λbv1. S(bv0)
    Check: S(S(x)) == S(S(x))
    ✓ Valid
[success] Total time: 0 s, completed 2026/02/19 3:55:03
[info] running romanesco.Solver.testLinearLogic 
[LOGGER] DISABLED
=== Linear Logic Test (Mapping Approach) ===

[Test Case] A ⊸ A
✓ Solved:
    ✓ A  {lh0}
  └─ ⊸(A,A)  {linear-implies-intro}

[Test Case] (A ⊗ B) ⊸ (A ⊗ B)
✓ Solved:
          ✓ A  {lh0}
          ✓ B  {lh2}
        └─ ⊗(A,B)  {tensor-intro}
      └─ ⊸(B,⊗(A,B))  {linear-implies-intro}
    └─ ⊸(A,⊸(B,⊗(A,B)))  {linear-implies-intro}
  └─ ⊸(⊗(A,B),⊗(A,B))  {tensor-limplies-destruct}

[Test Case] !A → A
✓ Solved:
      ✓ A  {h0}
    └─ A  {linear-bang-elim[h0]}
  └─ →(!(A),A)  {implies-intro}

[Test Case] A ⊗ B → A ∧ B
✓ Solved:
        ✓ A  {h0.1}
      └─ A  {tensor-is-ﾃ夕h0]}
      ✓ B  {h0.2}
    └─ ∧(A,B)  {product-intro}
  └─ →(⊗(A,B),∧(A,B))  {implies-intro}
[success] Total time: 1 s, completed 2026/02/19 3:55:03
[info] running romanesco.Solver.testMapFusion 
[LOGGER] DISABLED
=== Map Fusion Test ===
Goal: ∀f. ∀g. ∀xs. map(f, map(g, xs)) = map(f ∘ g, xs)
✓ Proof found:
        ✓ map(f_0,map(g_1,nil)) = map(∘(f_0,g_1),nil)  {true-intro}
              ✓ ⊤  {true-intro}
            └─ cons(f_0(g_1(a_0_3)),map(f_0,map(g_1,xs_1_4))) = cons(f_0(g_1(a_0_3)),map(∘(f_0,g_1),xs_1_4))  {rewrite[IH_xs_1]}
          └─ ∀(xs_1,cons(f_0(g_1(a_0_3)),map(f_0,map(g_1,xs_1))) = cons(∘(f_0,g_1)(a_0_3),map(∘(f_0,g_1),xs_1)))  {forall-intro}
        └─ ∀(a_0,∀(xs_1,cons(f_0(g_1(a_0)),map(f_0,map(g_1,xs_1))) = cons(∘(f_0,g_1)(a_0),map(∘(f_0,g_1),xs_1))))  {forall-intro}
      └─ ∀(xs,map(f_0,map(g_1,xs)) = map(∘(f_0,g_1),xs))  {induction[List]}
    └─ ∀(g,∀(xs,map(f_0,map(g,xs)) = map(∘(f_0,g),xs)))  {forall-intro}
  └─ ∀(f,∀(g,∀(xs,map(f,map(g,xs)) = map(∘(f,g),xs))))  {forall-intro}
[success] Total time: 1 s, completed 2026/02/19 3:55:05
[info] running romanesco.Solver.testModalLogic 
[LOGGER] DISABLED
=== Modal Logic Test ===
[Test Case] □(A → B) → (□A → □B)
✓ Solved:      ✓ □(→(A,B))  {h0}
    └─ →(□(A),□(B))  {modal-K}
  └─ →(□(→(A,B)),→(□(A),□(B)))  {implies-intro}
[Test Case] □A → A
✓ Solved:      ✓ A  {h0.T}
    └─ A  {box-elim-T[h0]}
  └─ →(□(A),A)  {implies-intro}
[Test Case] □A → □□A
✓ Solved:      ✓ □(A)  {h0}
    └─ □(□(A))  {box-intro}
  └─ →(□(A),□(□(A)))  {implies-intro}
[Test Case] ◇A → □◇A
✓ Solved:      ✓ ◇(A)  {h0}
    └─ □(◇(A))  {modal-5}
  └─ →(◇(A),□(◇(A)))  {implies-intro}
[Test Case] ◇A → (□(A → ⊥) → ⊥)
✓ Solved:      ✓ ◇(A)  {h0}
    └─ →(□(→(A,⊥)),⊥)  {modal-duality}
  └─ →(◇(A),→(□(→(A,⊥)),⊥))  {implies-intro}
[success] Total time: 1 s, completed 2026/02/19 3:55:05
[info] running romanesco.Solver.testPatternUnification 
[LOGGER] DISABLED
=== Pattern Unification Test ===
Test 1: ?P(x) = x = 0
Unifying: ?1(x) = x = 0
✓ Solutions found:
  Solution 0:
    ?1 -> λbv0. bv0 = 0
    Applied LHS: x = 0
    Normalized:  x = 0
    ✓ Valid solution

Test 2: ?M(x) = S(x)
Unifying: ?2(x) = S(x)
  Solution: λbv0. S(bv0)
[success] Total time: 0 s, completed 2026/02/19 3:55:06
[info] running romanesco.Solver.testTactics 
=== Tactic System Test ===
Initial state:
--------------------------------

--------------------------------
  Goal: →(∧(A,B),∧(B,A))

After intro:
--------------------------------
  h0: ∧(A,B)
--------------------------------
  Goal: ∧(B,A)

After destruct h0:
--------------------------------
  h0.1: A
  h0.2: B
--------------------------------
  Goal: ∧(B,A)

After split (Subgoal 1):
--------------------------------
  h0.1: A
  h0.2: B
--------------------------------
  Goal: B

After solve B (Subgoal 2):
--------------------------------
  h0.1: A
  h0.2: B
--------------------------------
  Goal: A

✓ Goal solved successfully using tactics!

=== Auto Tactic Test: A ∧ B → B ∧ A ===

After intro, calling auto on goal: --------------------------------
  h0: ∧(A,B)
--------------------------------
  Goal: ∧(B,A)
✓ Auto solved: ✓ ∧(B,A)  {h0}

✓ Auto tactic solved the goal with context!

=== Simpl Tactic Test: plus(0, n) = n ===

After intro:
--------------------------------

--------------------------------
  Goal: plus(0,n_t1) = n_t1

After simpl:
Solved

✓ Simpl tactic worked!

=== Induction Test: plus(n, 0) = n ===

Base Case:
--------------------------------

--------------------------------
  Goal: plus(0,0) = 0

Inductive Step:
--------------------------------

--------------------------------
  Goal: ∀(n,→(plus(n,0) = n,plus(S(n),0) = S(n)))

Base Case solved! Next goal:
--------------------------------

--------------------------------
  Goal: ∀(n,→(plus(n,0) = n,plus(S(n),0) = S(n)))

After intro n:
--------------------------------

--------------------------------
  Goal: →(plus(n_t1,0) = n_t1,plus(S(n_t1),0) = S(n_t1))

After intro IH:
--------------------------------
  IH: plus(n_t1,0) = n_t1
--------------------------------
  Goal: plus(S(n_t1),0) = S(n_t1)

After rewrite IH:
Solved

✓ Induction goal solved successfully!
[success] Total time: 1 s, completed 2026/02/19 3:55:06
[info] running romanesco.Solver.testTreeInduction 
[LOGGER] DISABLED
[LOGGER] Max log depth set to 20
=== Tree Induction Test ===
Goal: ∀t. reverse(reverse(t)) = t
✓ Proof found:
    ✓ reverse(reverse(t_0)) = t_0  {true-intro}
  └─ ∀(t,reverse(reverse(t)) = t)  {forall-intro}
[success] Total time: 1 s, completed 2026/02/19 3:55:07
[info] running romanesco.Solver.SolverTests.RecursiveInductionTest 
[LOGGER] DISABLED
=== Recursive Data Structure Induction Test ===
Case: ∀xs. append(xs, nil) = xs ... ✓ OK
Case: ∀xs. ∀ys. ∀zs. append(append(xs, ys), zs) = append(xs, append(ys, zs)) ... ✓ OK
  (Induction used)
Case: ∀t. mirror(mirror(t)) = t ... ✓ OK
Case: ∀xs. ∀ys. list_prop(append(xs, ys)) ... ✓ OK
[success] Total time: 1 s, completed 2026/02/19 3:55:08
[info] running romanesco.testSomeCases 
[LOGGER] DISABLED

=== Induction Test: plus(n, S(m)) = S(plus(n, m)) ===

Base Case solved! Next goal:
Goals:
  0: --------------------------------

--------------------------------
  Goal: ∀(n,→(∀(m,plus(n,S(m)) = S(plus(n,m))),∀(m,plus(S(n),S(m)) = S(plus(S(n),m)))))

After intros:
Goals:
  0: --------------------------------
  IH: ∀(m,plus(n_step,S(m)) = S(plus(n_step,m)))
--------------------------------
  Goal: plus(S(n_step),S(m)) = S(plus(S(n_step),m))

After rewrite IH:
Goals:

✓ Manual induction goal solved successfully!

=== Automatic Induction Tests ===

[Test Case] ∀n. plus(n, 0) = n
✓ Solved:
    ✓ plus(n_0,0) = n_0  {true-intro}
  └─ ∀(n,plus(n,0) = n)  {forall-intro}

[Test Case] ∀n. plus(0, n) = n
✓ Solved:
    ✓ plus(0,n_0) = n_0  {true-intro}
  └─ ∀(n,plus(0,n) = n)  {forall-intro}

[Test Case] ∀n. ∀m. plus(n, S(m)) = S(plus(n, m))
✓ Solved:
      ✓ plus(n_0,S(nothing)) = S(plus(n_0,nothing))  {true-intro}
    └─ ∀(m,plus(0,S(m)) = S(plus(0,m)))  {forall-intro}
      ✓ ∀(m,plus(S(n_0_1),S(m)) = S(plus(S(n_0_1),m)))  {IH_n_0}
    └─ ∀(n_0,∀(m,plus(S(n_0),S(m)) = S(plus(S(n_0),m))))  {forall-intro}
  └─ ∀(n,∀(m,plus(n,S(m)) = S(plus(n,m))))  {induction[Nat]}

[Test Case] ∀xs. append(xs, nil) = xs
✓ Solved:
    ✓ append(xs_0,nil) = xs_0  {true-intro}
  └─ ∀(xs,append(xs,nil) = xs)  {forall-intro}

[Test Case] ∀xs. append(nil, xs) = xs
✓ Solved:
    ✓ append(nil,xs_0) = xs_0  {true-intro}
  └─ ∀(xs,append(nil,xs) = xs)  {forall-intro}

[Test Case] ∀xs. ∀ys. ∀zs. append(append(xs, ys), zs) = append(xs, append(ys, zs))
✓ Solved:
        ✓ append(append(nil,ys_1),zs_2) = append(nil,append(ys_1,zs_2))  {true-intro}
      └─ ∀(zs,append(append(nil,ys_1),zs) = append(nil,append(ys_1,zs)))  {forall-intro}
    └─ ∀(ys,∀(zs,append(append(nil,ys),zs) = append(nil,append(ys,zs))))  {forall-intro}
        ✓ ∀(ys,∀(zs,append(append(cons(a_0_1,xs_1_2),ys),zs) = append(cons(a_0_1,xs_1_2),append(ys,zs))))  {IH_xs_1}
      └─ ∀(xs_1,∀(ys,∀(zs,append(append(cons(a_0_1,xs_1),ys),zs) = append(cons(a_0_1,xs_1),append(ys,zs)))))  {forall-intro}
    └─ ∀(a_0,∀(xs_1,∀(ys,∀(zs,append(append(cons(a_0,xs_1),ys),zs) = append(cons(a_0,xs_1),append(ys,zs))))))  {forall-intro}
  └─ ∀(xs,∀(ys,∀(zs,append(append(xs,ys),zs) = append(xs,append(ys,zs)))))  {induction[List]}

[Test Case] ∀n. ∀m. plus(n, m) = plus(m, n)
✓ Solved:
      ✓ plus(n_0,nothing) = plus(nothing,n_0)  {true-intro}
    └─ ∀(m,plus(0,m) = plus(m,0))  {forall-intro}
      ✓ ∀(m,plus(S(n_0_1),m) = plus(m,S(n_0_1)))  {IH_n_0}
    └─ ∀(n_0,∀(m,plus(S(n_0),m) = plus(m,S(n_0))))  {forall-intro}
  └─ ∀(n,∀(m,plus(n,m) = plus(m,n)))  {induction[Nat]}

[Test Case] ∀n. ∀m. ∀k. plus(plus(n, m), k) = plus(n, plus(m, k))
✓ Solved:
        ✓ plus(plus(0,nothing),k_2) = plus(0,plus(nothing,k_2))  {true-intro}
      └─ ∀(k,plus(plus(n_0,nothing),k) = plus(n_0,plus(nothing,k)))  {forall-intro}
          ✓ plus(plus(0,nothing),k_2) = plus(0,plus(nothing,k_2))  {true-intro}
        └─ ∀(k,plus(plus(n_0,nothing),k) = plus(n_0,plus(nothing,k)))  {forall-intro}
      └─ ∀(a_0,∀(k,plus(plus(n_0,just(a_0)),k) = plus(n_0,plus(just(a_0),k))))  {forall-intro}
    └─ ∀(m,∀(k,plus(plus(n_0,m),k) = plus(n_0,plus(m,k))))  {induction[Maybe]}
  └─ ∀(n,∀(m,∀(k,plus(plus(n,m),k) = plus(n,plus(m,k)))))  {forall-intro}
[success] Total time: 1 s, completed 2026/02/19 3:55:09
[info] running romanesco.Solver.SolverTests.CombinedLogicTest 
=== Combined Multi-Logic Test ===

[Test Case] G(A ⊸ B) → (G(A) ⊸ G(B))
✓ Solved!
      ✓ G(⊸(A,B))  {h0}
    └─ ⊸(G(A),G(B))  {G-dist-limplies}
  └─ →(G(⊸(A,B)),⊸(G(A),G(B)))  {implies-intro}

[Test Case] □(A ⊸ B) → (□A ⊸ □B)
✓ Solved!
      ✓ □(⊸(A,B))  {h0}
    └─ ⊸(□(A),□(B))  {modal-K-linear}
  └─ →(□(⊸(A,B)),⊸(□(A),□(B)))  {implies-intro}

[Test Case] G(A * B) ⊸ (G(A) * G(B))
✓ Solved!
      ✓ G(*(A,B))  {lh0}
    └─ *(G(A),G(B))  {G-dist-sepand}
  └─ ⊸(G(*(A,B)),*(G(A),G(B)))  {linear-implies-intro}

[Test Case] □G(A ⊸ B) → G(□A ⊸ □B)
✓ Solved!
        ✓ □(G(⊸(A,B)))  {h0}
      └─ G(□(⊸(A,B)))  {modal-box-G}
    └─ G(⊸(□(A),□(B)))  {G-modal-K-linear}
  └─ →(□(G(⊸(A,B))),G(⊸(□(A),□(B))))  {implies-intro}

[Test Case] □(A * B) → (□A * □B)
✓ Solved!
      ✓ □(*(A,B))  {h0}
    └─ *(□(A),□(B))  {modal-dist-sepand}
  └─ →(□(*(A,B)),*(□(A),□(B)))  {implies-intro}

[Test Case] G(∀x. A(x) ⊸ B(x)) → ∀x. (G(A(x)) ⊸ G(B(x)))
✓ Solved!
      ✓ G(∀(x,⊸(A(x),B(x))))  {h0}
    └─ ∀(x,⊸(G(A(x)),G(B(x))))  {modal-dist-forall-limplies}
  └─ →(G(∀(x,⊸(A(x),B(x)))),∀(x,⊸(G(A(x)),G(B(x)))))  {implies-intro}

[Test Case] ∀x. □(P(x) ⊸ Q(x)) → ∀x. (□P(x) ⊸ □Q(x))
✓ Solved!
          ✓ □(⊸(P(x_0_2),Q(x_0_2)))  {h1}
        └─ ⊸(□(P(x_0_2)),□(Q(x_0_2)))  {modal-K-linear}
      └─ ∀(x_0,⊸(□(P(x_0)),□(Q(x_0))))  {forall-intro}
    └─ →(□(⊸(P(x_0),Q(x_0))),∀(x_0,⊸(□(P(x_0)),□(Q(x_0)))))  {implies-intro}
  └─ ∀(x,→(□(⊸(P(x),Q(x))),∀(x,⊸(□(P(x)),□(Q(x))))))  {forall-intro}
[success] Total time: 1 s, completed 2026/02/19 3:55:10
[info] running romanesco.Solver.SolverTests.runAllAdditionalTestsSuite 
============================================================
Phase 1 Additional Tests
============================================================
=== Phase 1: Advanced Arithmetic ===
[LOGGER] DISABLED
[LOGGER] Max log depth set to 10
✓ OK: Plus Commutative
✓ OK: Plus Associative

=== Phase 1: Advanced Lists ===
[LOGGER] DISABLED
[LOGGER] Max log depth set to 10
✓ OK: Append Associative
✓ OK: Reverse Reverse
✓ OK: Map Composition
============================================================

============================================================
Advanced Test Suite
============================================================
[LOGGER] DISABLED
[LOGGER] Max log depth set to 10
=== Dependent Type: Vector Tests ===
[LOGGER] DISABLED
[LOGGER] Max log depth set to 10
✓ OK: Vector head extraction
✗ FAIL: Vector length preservation - No proof found
✗ FAIL: Vector map identity - No proof found

=== Inductive Predicate: Graph Reachability ===
[LOGGER] DISABLED
[LOGGER] Max log depth set to 10
✓ OK: Reflexivity
✓ OK: Edge implies reach

=== Coinductive: Infinite Streams ===
[LOGGER] DISABLED
[LOGGER] Max log depth set to 5
✓ OK: Stream head of repeat
✓ OK: Stream bisimulation (self)

=== Category Theory: Monad Laws ===
[LOGGER] DISABLED
[LOGGER] Max log depth set to 5
✓ OK: List Monad: Left Identity
✓ OK: List Monad: Right Identity
✓ OK: List Monad: Associativity
✓ OK: Maybe Monad: Left Identity
✓ OK: Maybe Monad: Right Identity
✓ OK: Maybe Monad: Associativity
============================================================
[success] Total time: 2 s, completed 2026/02/19 3:55:12
[info] running romanesco.Solver.SolverTests.runPhase1TestsSuite 
============================================================
Phase 1 Additional Tests
============================================================
=== Phase 1: Advanced Arithmetic ===
[LOGGER] DISABLED
[LOGGER] Max log depth set to 10
✓ OK: Plus Commutative
✓ OK: Plus Associative

=== Phase 1: Advanced Lists ===
[LOGGER] DISABLED
[LOGGER] Max log depth set to 10
✓ OK: Append Associative
✓ OK: Reverse Reverse
✓ OK: Map Composition
============================================================
[success] Total time: 1 s, completed 2026/02/19 3:55:13
[info] running romanesco.Solver.SolverTests.runAdvancedTestsSuite 
============================================================
Advanced Test Suite
============================================================
[LOGGER] DISABLED
[LOGGER] Max log depth set to 10
=== Dependent Type: Vector Tests ===
[LOGGER] DISABLED
[LOGGER] Max log depth set to 10
✓ OK: Vector head extraction
✗ FAIL: Vector length preservation - No proof found
✗ FAIL: Vector map identity - No proof found

=== Inductive Predicate: Graph Reachability ===
[LOGGER] DISABLED
[LOGGER] Max log depth set to 10
✓ OK: Reflexivity
✓ OK: Edge implies reach

=== Coinductive: Infinite Streams ===
[LOGGER] DISABLED
[LOGGER] Max log depth set to 5
✓ OK: Stream head of repeat
✓ OK: Stream bisimulation (self)

=== Category Theory: Monad Laws ===
[LOGGER] DISABLED
[LOGGER] Max log depth set to 5
✓ OK: List Monad: Left Identity
✓ OK: List Monad: Right Identity
✓ OK: List Monad: Associativity
✓ OK: Maybe Monad: Left Identity
✓ OK: Maybe Monad: Right Identity
✓ OK: Maybe Monad: Associativity
============================================================
[success] Total time: 1 s, completed 2026/02/19 3:55:14
[info] running romanesco.Solver.SolverTests.HoTTAdvancedTest 
[LOGGER] DISABLED
=== HoTT Phase 1: Transport Computation Test ===
Case: transport(λz. ×(A(z), B(z)), p, pair(u, v)) = pair(transport(λz. A(z), p, u), transport(λz. B(z), p, v)) ... ✓ OK (Solved)
Case: transport(λz. +(A(z), B(z)), p, inl(u)) = inl(transport(λz. A(z), p, u)) ... ✓ OK (Solved)
Case: transport(λz. →(A(z), B(z)), p, f) = λx. transport(λz. B(z), p, f(transport(λz. A(z), inv(p), x))) ... ✓ OK (Solved)
Case: isProp(A) → ∀x:A. ∀y:A. path(A, x, y) ... ✓ OK (Solved)
Case: isProp(A) → isSet(A) ... ✓ OK (Solved)
Case: (isProp(A) ∧ isProp(B)) → isProp(×(A, B)) ... ✓ OK (Solved)
Case: isSet(A) → ∀x:A. ∀y:A. ∀p:path(A, x, y). ∀q:path(A, x, y). path(path(A, x, y), p, q) ... ✗ FAIL (Should have been solved) - Reason: Watchdog timeout
Case: (P(zero) ∧ P(one) ∧ path(Type, P(zero), P(one))) → ∀i:Interval. P(i) ... ✓ OK (Solved)
Case: (P(north) ∧ P(south) ∧ ∀a. path(Type, P(north), P(south))) → ∀s:Susp. P(s) ... ✗ FAIL (Should have been solved) - Reason: No proof found
Case: comp(A, refl(x), u) = u ... ✓ OK (Solved)

=== Phase 5: Proof Mining Test ===
✓ OK: Complex arithmetic solved with dynamic lemmas
[success] Total time: 17 s, completed 2026/02/19 3:55:31
[info] running romanesco.Solver.SolverTests.UnificationAdvancedTest 
[LOGGER] DISABLED
=== Advanced Unification Test ===
[Case: Duplicate Args]
Unifying: ?1(x,x) = f(x)
✓ Solution 0: Map(1 -> λbv0. λbv1. f(bv0))
  Check: f(x) == f(x)
[Case: Partial Dependency]
Unifying: ?2(x,y) = f(x)
✓ Solution 0: Map(2 -> λbv0. λbv1. f(bv0))
  Check: f(x) == f(x)
[Case: Structured Args]
Unifying: ?3(S(x)) = S(S(x))
✓ Solution 0: Map(3 -> λbv0. S(bv0))
  Check: S(S(x)) == S(S(x))
[Case: Nested Meta]
Unifying: ?4(x) = f(?5(x))
✓ Solution 0: Map(4 -> λbv0. f(?5(bv0)))
  Check: f(?5(x)) == f(?5(x))
[Case: Non-deterministic Abstraction]
Unifying: ?6(x,x) = f(x,x)
✓ Solution 0: Map(6 -> λbv0. λbv1. f(bv0,bv0))
  Check: f(x,x) == f(x,x)
[Case: Pruning]
Unifying: ?7(x) = f(?8(x,y))
✓ Solution 0: Map(8 -> λmv0. λmv1. ?8.888(mv0), 7 -> λbv0. f(?8.888(bv0)))
  Check: f(?8.888(x)) == f(?8.888(x))
[success] Total time: 0 s, completed 2026/02/19 3:55:32
[info] running romanesco.Solver.SolverTests.EnhancedFrameTest 
[LOGGER] DISABLED
=== Enhanced Frame Inference Test ===
Case: Basic frame ... ✓ OK
Case: Points-to frame ... ✓ OK
Case: Multi-resource frame ... ✓ OK
Case: Minimal frame (C * D) ... ✓ OK
Case: Minimal frame (x ↦ 1 * z ↦ 3) ... ✓ OK
Case: Frame rule application ... ✓ OK
Case: File handle frame ... ✓ OK
Case: Lock and memory frame ... ✓ OK
[success] Total time: 7 s, completed 2026/02/19 3:55:39
[info] running romanesco.Solver.SolverTests.runMathAndVerificationTests 
=== Extended Arithmetic Verification ===
Case: plus(S(0), S(0)) = S(S(0)) ... ✓ OK
✓ plus(S(0),S(0)) = S(S(0))  {true-intro}
Case: plus(n, plus(m, k)) = plus(m, plus(n, k)) ... ✓ OK
✓ plus(S(0),S(0)) = S(S(0))  {true-intro}

=== Hoare Logic Program Verification ===
Case: {x = 1} skip {x = 1} ... ✓ OK
    ✓ x = 1  {h1}
  └─ →(x = 1,x = 1)  {implies-intro}
└─ triple(x = 1,skip,x = 1)  {hoare-skip}
Case: {⊤} x := 1 {x = 1} ... ✓ OK
    ✓ 1 = 1  {true-intro}
  └─ →(⊤,1 = 1)  {implies-intro}
└─ triple(⊤,:=(x,1),x = 1)  {hoare-assign}
Case: {⊤} x := 1 ; y := 2 {x = 1 ∧ y = 2} ... ✓ OK
      ✓ 1 = 1  {true-intro}
    └─ →(⊤,⊤)  {implies-intro}
  └─ triple(⊤,:=(x,1),x = 1)  {hoare-assign}
      ✓ x = 1  {h2}
    └─ →(x = 1,x = 1)  {implies-intro}
  └─ triple(x = 1,:=(y,2),∧(x = 1,y = 2))  {hoare-assign}
└─ triple(⊤,;(:=(x,1),:=(y,2)),∧(x = 1,y = 2))  {hoare-seq}
[success] Total time: 1 s, completed 2026/02/19 3:55:40
