Active code page: 65001
[info] welcome to sbt 1.12.1 (Oracle Corporation Java 25.0.2)
[info] loading project definition from C:\Users\Cocoa\romanesco\project\project\project
[info] loading settings for project romanesco-build-build from metals.sbt...
[info] loading project definition from C:\Users\Cocoa\romanesco\project\project
[info] loading settings for project romanesco-build from metals.sbt, plugins.sbt...
[info] loading project definition from C:\Users\Cocoa\romanesco\project
[info] loading settings for project root from build.sbt...
[info] set current project to romanesco (in build file:/C:/Users/Cocoa/romanesco/)
[info] running romanesco.Solver.SolverTests.CycleTest 
[LOGGER] DISABLED
=== Cycle Detection Test ===
Testing simple loop: P(a)
Failed as expected: No proof found
Testing loop with Forall: 竏(x,P(x))
Failed: No proof found
Testing complex loop: P(a) -> Q(a) -> P(a)
Failed: No proof found
Testing growth loop: P(a) -> P(f(a))
Failed: No proof found
[success] Total time: 2 s, completed 2026/02/14 19:42:52
[info] running romanesco.Solver.SolverTests.CycleTest2 
[LOGGER] DISABLED
=== Cycle Detection Test 2 (Inner Branch) ===
Testing loop: P(a)
[success] Total time: 0 s, completed 2026/02/14 19:42:52
[info] running romanesco.Solver.SolverTests.DebugAssoc 
[LOGGER] DISABLED
[LOGGER] Max log depth set to 10
=== Debug: Path Associativity ===
笨・Solved!
              笨・竓､  {true-intro}
            笏披楳 竏(r,path(A,z_2,w_3),竓､)  {forall-intro}
          笏披楳 竏(q,path(A,y_1,z_2),竏(r,path(A,z_2,w_3),竓､))  {forall-intro}
        笏披楳 竏(p,path(A,x_0,y_1),竏(q,path(A,y_1,z_2),竏(r,path(A,z_2,w_3),竓､)))  {forall-intro}
      笏披楳 竏(w,竏(p,path(A,x_0,y_1),竏(q,path(A,y_1,z_2),竏(r,path(A,z_2,w),竓､))))  {forall-intro}
    笏披楳 竏(z,竏(w,竏(p,path(A,x_0,y_1),竏(q,path(A,y_1,z),竏(r,path(A,z,w),竓､)))))  {forall-intro}
  笏披楳 竏(y,竏(z,竏(w,竏(p,path(A,x_0,y),竏(q,path(A,y,z),竏(r,path(A,z,w),竓､))))))  {forall-intro}
笏披楳 竏(x,竏(y,竏(z,竏(w,竏(p,path(A,x,y),竏(q,path(A,y,z),竏(r,path(A,z,w),竓､)))))))  {forall-intro}
[success] Total time: 1 s, completed 2026/02/14 19:42:53
[info] running romanesco.Solver.SolverTests.DebugLinear 
[LOGGER] DISABLED
=== Debug: A 竓ｸ B 竓ｸ (A 竓・B) ===
笨・Solved!
      笨・A  {lh0}
    笏披楳 竓・A,B)  {cancel[lh1]}
  笏披楳 竓ｸ(B,竓・A,B))  {linear-implies-intro}
笏披楳 竓ｸ(A,竓ｸ(B,竓・A,B)))  {linear-implies-intro}
[success] Total time: 0 s, completed 2026/02/14 19:42:54
[info] running romanesco.Solver.SolverTests.HoTTCubeTest 
[LOGGER] DISABLED
=== HoTT: Cubical Model Approximation Test ===
Case: cube(A, p, q, r, s) 竊・path(path(A, x, y), p, r) ... 笨・OK (Solved)
Case: cube(A, p, q, r, s) 竊・path(path(A, x, z), q, s) ... 笨・OK (Failed as expected)
[success] Total time: 0 s, completed 2026/02/14 19:42:54
[info] running romanesco.Solver.SolverTests.HoTTTest 
[LOGGER] DISABLED
=== HoTT: Path Induction and HIT Test ===
Case: 竏x. 竏y. 竏p:path(A,x,y). concat(p, refl(y)) = p ... 笨・OK (Solved)
Case: 竏x. 竏y. 竏p:path(A,x,y). concat(refl(x), p) = p ... 笨・OK (Solved)
Case: 竏x. 竏y. 竏z. 竏w. 竏p:path(A,x,y). 竏q:path(A,y,z). 竏r:path(A,z,w). concat(concat(p, q), r) = concat(p, concat(q, r)) ... 笨・OK (Solved)
Case: 竏x. 竏y. 竏p:path(A,x,y). inv(inv(p)) = p ... 笨・OK (Solved)
Case: 竏x:S1. P(base) 竊・P(x) ... 笨・OK (Solved)
Case: equiv(A, B) 竊・path(Type, A, B) ... 笨・OK (Solved)
[success] Total time: 1 s, completed 2026/02/14 19:42:55
[info] running romanesco.Solver.SolverTests.LinearResourceTest 
[LOGGER] DISABLED
=== Linear Logic: Resource Consumption Test ===
Case: A 竓ｸ A ... 笨・OK (Solved as expected)
Case: (A 竓・B) 竓ｸ (B 竓・A) ... 笨・OK (Solved as expected)
Case: A 竓ｸ (A 竓・A) ... 笨・OK (Failed as expected)
Case: A 竓ｸ B 竓ｸ (A 竓・B) ... 笨・OK (Solved as expected)
Case: (A 竓・A) 竓ｸ A ... 笨・OK (Failed as expected)
[success] Total time: 0 s, completed 2026/02/14 19:42:55
[info] running romanesco.Solver.SolverTests.SeparationLogicTest 
[LOGGER] DISABLED
=== Separation Logic: Resource Management Test ===
Case: A * B 竓ｸ B * A (depth 10) ... 笨・OK (Solved)
Case: (A * B) * C 竓ｸ A * (B * C) (depth 10) ... 笨・OK (Solved)
Case: (A 竓ｸ B) 竓ｸ (A * C 竓ｸ B * C) (depth 15) ... 笨・OK (Solved)
Case: (A * A) 竓ｸ A (depth 5) ... 笨・OK (Failed as expected)
Case: (A 竓ｸ A) * A (depth 5) ... 笨・OK (Failed as expected)
Case: (竏v. (x 竊ｦ v 竓ｸ P(v))) 竓ｸ (x 竊ｦ 5 竓ｸ P(5)) (depth 8) ... 笨・OK (Solved)
Case: A * B * C 竓ｸ C * A * B (depth 8) ... 笨・OK (Solved)
Case: (竏v. (x 竊ｦ v * R)) 竓ｸ (x 竊ｦ 5 * R) (depth 8) ... 笨・OK (Solved)
Case: 竏ェ. (A * B 竓ｸ A * F) (depth 10) ... 笨・OK (Solved)
Case: 竏ェ. (x 竊ｦ 1 * y 竊ｦ 2 竓ｸ x 竊ｦ 1 * F) (depth 10) ... 笨・OK (Solved)
Case: 竏ェ. (A * B * C 竓ｸ B * F) (depth 10) ... 笨・OK (Solved)
[success] Total time: 1 s, completed 2026/02/14 19:42:56
[info] running romanesco.Solver.SolverTests.TemporalLogicTest 
[LOGGER] DISABLED
=== Temporal Logic: Co-induction Test ===
Case: G(A) 竊・A ... 笨・OK (Solved)
Case: G(A) 竊・X(A) ... 笨・OK (Solved)
Case: G(A) 竊・G(G(A)) ... 笨・OK (Solved)
Case: G(A 竊・B) 竊・G(A) 竊・G(B) ... 笨・OK (Solved)
[success] Total time: 0 s, completed 2026/02/14 19:42:57
[info] running romanesco.Solver.SolverTests.TypeLevelTest 
[LOGGER] DISABLED
=== Strict Universe Level Unification Test ===
Proving: Type0 = Type0 ...
笨・OK (Solved)
Proving: Type0 = Type1 ...
笨・OK (Failed as expected)
[success] Total time: 0 s, completed 2026/02/14 19:42:57
[info] running romanesco.Solver.SolverTests.HoareLogicTest 
[LOGGER] DISABLED
=== Hoare Logic: Program Verification Test ===
Case: {x = 1} skip {x = 1} ... 笨・OK (Solved)
Case: {竓､} x := 1 {x = 1} ... 笨・OK (Solved)
Case: {竓､} x := 1 ; y := 2 {x = 1 竏ｧ y = 2} ... 笨・OK (Solved)
Case: {竓､} if (x = 0) x := 1 else x := 2 {x = 1 竏ｨ x = 2} ... 笨・OK (Solved)
Case: {x = 0} while [x = 0 竏ｨ x = 1] (x = 0) x := 1 {x = 1} ... 笨・OK (Solved)
[success] Total time: 1 s, completed 2026/02/14 19:42:58
[info] running romanesco.Solver.testGeneralizedUnification 
[LOGGER] DISABLED
=== Generalized Higher-Order Unification Test ===

Test 1: ?P(f(x)) = g(f(x))
Unifying: ?1(f(x)) = g(f(x))
笨・Solutions found:
  Solution 0:
    ?1 -> ﾎｻv_0. g(v_0)
    Check: g(f(x)) == g(f(x))
    笨・Valid
  Solution 1:
    ?1 -> ﾎｻv_0. g(f(x))
    Check: g(f(x)) == g(f(x))
    笨・Valid

Test 2: ?P(a, b) = f(b, a)
Unifying: ?1(a,b) = f(b,a)
笨・Solutions found:
  Solution 0:
    ?1 -> ﾎｻv_0. ﾎｻv_1. f(v_1,v_0)
    Check: f(b,a) == f(b,a)
    笨・Valid
  Solution 1:
    ?1 -> ﾎｻv_0. ﾎｻv_1. f(v_1,a)
    Check: f(b,a) == f(b,a)
    笨・Valid
  Solution 2:
    ?1 -> ﾎｻv_0. ﾎｻv_1. f(b,v_0)
    Check: f(b,a) == f(b,a)
    笨・Valid
  Solution 3:
    ?1 -> ﾎｻv_0. ﾎｻv_1. f(b,a)
    Check: f(b,a) == f(b,a)
    笨・Valid

Test 3: ?P(S(x), x) = S(S(x))
Unifying: ?1(S(x),x) = S(S(x))
笨・Solutions found:
  Solution 0:
    ?1 -> ﾎｻv_0. ﾎｻv_1. S(v_0)
    Check: S(S(x)) == S(S(x))
    笨・Valid
  Solution 1:
    ?1 -> ﾎｻv_0. ﾎｻv_1. S(S(v_1))
    Check: S(S(x)) == S(S(x))
    笨・Valid
  Solution 2:
    ?1 -> ﾎｻv_0. ﾎｻv_1. S(S(x))
    Check: S(S(x)) == S(S(x))
    笨・Valid
[success] Total time: 0 s, completed 2026/02/14 19:42:58
[info] running romanesco.Solver.testLinearLogic 
[LOGGER] DISABLED
=== Linear Logic Test (Mapping Approach) ===

[Test Case] A 竓ｸ A
笨・Solved:
    笨・A  {linear:lh0}
  笏披楳 竓ｸ(A,A)  {linear-implies-intro}

[Test Case] (A 竓・B) 竓ｸ (A 竓・B)
笨・Solved:
    笨・竓・A,B)  {linear:lh0}
  笏披楳 竓ｸ(竓・A,B),竓・A,B))  {linear-implies-intro}

[Test Case] !A 竊・A
笨・Solved:
      笨・A  {h0}
    笏披楳 A  {linear-bang-elim[h0]}
  笏披楳 竊・!(A),A)  {implies-intro}

[Test Case] A 竓・B 竊・A 竏ｧ B
笨・Solved:
          笨・A  {h0.1}
          笨・B  {h0.2}
        笏披楳 竏ｧ(A,B)  {product-intro}
      笏披楳 竏ｧ(A,B)  {destruct[h0]}
    笏披楳 竏ｧ(A,B)  {tensor-is-ﾃ夕h0]}
  笏披楳 竊・竓・A,B),竏ｧ(A,B))  {implies-intro}
[success] Total time: 0 s, completed 2026/02/14 19:42:58
[info] running romanesco.Solver.testMapFusion 
[LOGGER] DISABLED
=== Map Fusion Test ===
Goal: 竏f. 竏g. 竏xs. map(f, map(g, xs)) = map(f 竏・g, xs)
笨・Proof found:
        笨・竓､  {true-intro}
                笨・竓､  {true-intro}
              笏披楳 cons(f_0(g_1(a_0_3)),nil) = cons(竏・f_0,g_1)(a_0_3),nil)  {compose_app}
                      笨・竓､  {true-intro}
                    笏披楳 cons(f_0(g_1(a_0_3)),cons(竏・f_0,g_1)(a_0_7),map(竏・f_0,g_1),xs_1_1_8))) = cons(竏・f_0,g_1)(a_0_3),cons(竏・f_0,g_1)(a_0_7),map(竏・f_0,g_1),xs_1_1_8)))  {compose_app}
                  笏披楳 竏(xs_1_1,cons(f_0(g_1(a_0_3)),cons(竏・f_0,g_1)(a_0_7),map(竏・f_0,g_1),xs_1_1))) = cons(竏・f_0,g_1)(a_0_3),cons(竏・f_0,g_1)(a_0_7),map(竏・f_0,g_1),xs_1_1))))  {forall-intro}
                笏披楳 竏(a_0,竏(xs_1_1,cons(f_0(g_1(a_0_3)),cons(竏・f_0,g_1)(a_0),map(竏・f_0,g_1),xs_1_1))) = cons(竏・f_0,g_1)(a_0_3),cons(竏・f_0,g_1)(a_0),map(竏・f_0,g_1),xs_1_1)))))  {forall-intro}
              笏披楳 竏(a_0,竏(xs_1_1,cons(f_0(g_1(a_0_3)),cons(竏・f_0,g_1)(a_0),map(竏・f_0,g_1),xs_1_1))) = cons(竏・f_0,g_1)(a_0_3),cons(竏・f_0,g_1)(a_0),map(竏・f_0,g_1),xs_1_1)))))  {compose_app[IH_xs_1_1]}
            笏披楳 竏(xs_1,cons(f_0(g_1(a_0_3)),map(竏・f_0,g_1),xs_1)) = cons(竏・f_0,g_1)(a_0_3),map(竏・f_0,g_1),xs_1)))  {induction[List]}
          笏披楳 竏(xs_1,cons(f_0(g_1(a_0_3)),map(f_0,map(g_1,xs_1))) = cons(竏・f_0,g_1)(a_0_3),map(竏・f_0,g_1),xs_1)))  {rewrite[IH_xs_1]}
        笏披楳 竏(a_0,竏(xs_1,cons(f_0(g_1(a_0)),map(f_0,map(g_1,xs_1))) = cons(竏・f_0,g_1)(a_0),map(竏・f_0,g_1),xs_1))))  {forall-intro}
      笏披楳 竏(xs,map(f_0,map(g_1,xs)) = map(竏・f_0,g_1),xs))  {induction[List]}
    笏披楳 竏(g,竏(xs,map(f_0,map(g,xs)) = map(竏・f_0,g),xs)))  {forall-intro}
  笏披楳 竏(f,竏(g,竏(xs,map(f,map(g,xs)) = map(竏・f,g),xs))))  {forall-intro}
[success] Total time: 2 s, completed 2026/02/14 19:43:01
[info] running romanesco.Solver.testModalLogic 
[LOGGER] DISABLED
=== Modal Logic Test ===
[Test Case] 笆｡(A 竊・B) 竊・(笆｡A 竊・笆｡B)
笨・Solved:      笨・竊・笆｡(A),笆｡(B))  {h0}
    笏披楳 竊・笆｡(A),笆｡(B))  {modal-K[h0]}
  笏披楳 竊・笆｡(竊・A,B)),竊・笆｡(A),笆｡(B)))  {implies-intro}
[Test Case] 笆｡A 竊・A
笨・Solved:      笨・A  {h0}
    笏披楳 A  {modal-T[h0]}
  笏披楳 竊・笆｡(A),A)  {implies-intro}
[Test Case] 笆｡A 竊・笆｡笆｡A
笨・Solved:      笨・笆｡(笆｡(A))  {h0}
    笏披楳 笆｡(笆｡(A))  {modal-4[h0]}
  笏披楳 竊・笆｡(A),笆｡(笆｡(A)))  {implies-intro}
[Test Case] 笳② 竊・笆｡笳②
笨・Solved:      笨・笆｡(笳・A))  {h0}
    笏披楳 笆｡(笳・A))  {modal-5[h0]}
  笏披楳 竊・笳・A),笆｡(笳・A)))  {implies-intro}
[Test Case] 笳② 竊・(笆｡(A 竊・竓･) 竊・竓･)
笨・Solved:      笨・竊・笆｡(竊・A,竓･)),竓･)  {h0}
    笏披楳 竊・笆｡(竊・A,竓･)),竓･)  {modal-duality[h0]}
  笏披楳 竊・笳・A),竊・笆｡(竊・A,竓･)),竓･))  {implies-intro}
[success] Total time: 1 s, completed 2026/02/14 19:43:02
[info] running romanesco.Solver.testPatternUnification 
[LOGGER] DISABLED
=== Pattern Unification Test ===
Test 1: ?P(x) = x = 0
Unifying: ?1(x) = x = 0
笨・Solutions found:
  Solution 0:
    ?1 -> ﾎｻv_0. v_0 = 0
    Applied LHS: x = 0
    Normalized:  x = 0
    笨・Valid solution
  Solution 1:
    ?1 -> ﾎｻv_0. x = 0
    Applied LHS: x = 0
    Normalized:  x = 0
    笨・Valid solution

Test 2: ?M(x) = S(x)
Unifying: ?2(x) = S(x)
  Solution: ﾎｻv_0. S(v_0)
[success] Total time: 0 s, completed 2026/02/14 19:43:02
[info] running romanesco.Solver.testTactics 
=== Tactic System Test ===
Initial state:
--------------------------------

--------------------------------
  Goal: 竊・竏ｧ(A,B),竏ｧ(B,A))

After intro:
--------------------------------
  h0: 竏ｧ(A,B)
--------------------------------
  Goal: 竏ｧ(B,A)

After destruct h0:
--------------------------------
  h0.1: A
  h0.2: B
--------------------------------
  Goal: 竏ｧ(B,A)

After split (Subgoal 1):
--------------------------------
  h0.1: A
  h0.2: B
--------------------------------
  Goal: B

After solve B (Subgoal 2):
--------------------------------
  h0.1: A
  h0.2: B
--------------------------------
  Goal: A

笨・Goal solved successfully using tactics!

=== Auto Tactic Test: A 竏ｧ B 竊・B 竏ｧ A ===

After intro, calling auto on goal: --------------------------------
  h0: 竏ｧ(A,B)
--------------------------------
  Goal: 竏ｧ(B,A)
笨・Auto solved: 笨・竏ｧ(A,B)  {h0}

笨・Auto tactic solved the goal with context!

=== Simpl Tactic Test: plus(0, n) = n ===

After intro:
--------------------------------

--------------------------------
  Goal: plus(0,n_t1) = n_t1

After simpl:
Solved

笨・Simpl tactic worked!

=== Induction Test: plus(n, 0) = n ===

Base Case:
--------------------------------

--------------------------------
  Goal: plus(0,0) = 0

Inductive Step:
--------------------------------

--------------------------------
  Goal: 竏(n,竊・plus(n,0) = n,plus(S(n),0) = S(n)))

Base Case solved! Next goal:
--------------------------------

--------------------------------
  Goal: 竏(n,竊・plus(n,0) = n,plus(S(n),0) = S(n)))

After intro n:
--------------------------------

--------------------------------
  Goal: 竊・plus(n_t1,0) = n_t1,plus(S(n_t1),0) = S(n_t1))

After intro IH:
--------------------------------
  IH: plus(n_t1,0) = n_t1
--------------------------------
  Goal: plus(S(n_t1),0) = S(n_t1)

After rewrite IH:
Solved

笨・Induction goal solved successfully!
[success] Total time: 0 s, completed 2026/02/14 19:43:02
[info] running romanesco.Solver.testTreeInduction 
[LOGGER] DISABLED
=== Tree Induction Test ===
Goal: 竏t. reverse(reverse(t)) = t
笨・Proof found:
        笨・竓､  {true-intro}
      笏披楳 reverse(leaf) = leaf  {reverse_leaf}
    笏披楳 reverse(reverse(leaf)) = leaf  {reverse_leaf}
                  笨・竓､  {true-intro}
                笏披楳 竏(t_2,竓､)  {forall-intro}
              笏披楳 竏(a_1,竏(t_2,竓､))  {forall-intro}
            笏披楳 竏(t_0,竏(a_1,竏(t_2,竓､)))  {forall-intro}
          笏披楳 竏(t_0,竏(a_1,竏(t_2,node(reverse(reverse(t_0)),a_1,t_2) = node(t_0,a_1,t_2))))  {rewrite[IH_t_0]}
        笏披楳 竏(t_0,竏(a_1,竏(t_2,node(reverse(reverse(t_0)),a_1,reverse(reverse(t_2))) = node(t_0,a_1,t_2))))  {rewrite[IH_t_2]}
      笏披楳 竏(t_0,竏(a_1,竏(t_2,reverse(node(reverse(t_2),a_1,reverse(t_0))) = node(t_0,a_1,t_2))))  {reverse_node}
    笏披楳 竏(t_0,竏(a_1,竏(t_2,reverse(reverse(node(t_0,a_1,t_2))) = node(t_0,a_1,t_2))))  {reverse_node}
  笏披楳 竏(t,reverse(reverse(t)) = t)  {induction[Tree]}
[success] Total time: 1 s, completed 2026/02/14 19:43:03
[info] running romanesco.Solver.SolverTests.RecursiveInductionTest 
[LOGGER] DISABLED
=== Recursive Data Structure Induction Test ===
Case: 竏xs. append(xs, nil) = xs ... 笨・OK
Case: 竏xs. 竏ys. 竏zs. append(append(xs, ys), zs) = append(xs, append(ys, zs)) ... 笨・OK
Case: 竏t. mirror(mirror(t)) = t ... 笨・OK
  (Induction used)
Case: 竏xs. 竏ys. list_prop(append(xs, ys)) ... 笨・OK
[success] Total time: 6 s, completed 2026/02/14 19:43:10
[info] running romanesco.testSomeCases 
[LOGGER] DISABLED

=== Induction Test: plus(n, S(m)) = S(plus(n, m)) ===

Base Case solved! Next goal:
Goals:
  0: --------------------------------

--------------------------------
  Goal: 竏(n,竊・竏(m,plus(n,S(m)) = S(plus(n,m))),竏(m,plus(S(n),S(m)) = S(plus(S(n),m)))))

After intros:
Goals:
  0: --------------------------------
  IH: 竏(m,plus(n_step,S(m)) = S(plus(n_step,m)))
--------------------------------
  Goal: plus(S(n_step),S(m)) = S(plus(S(n_step),m))

After rewrite IH:
Goals:

笨・Manual induction goal solved successfully!

=== Automatic Induction Tests ===

[Test Case] 竏n. plus(n, 0) = n
笨・Solved:
    笨・竓､  {true-intro}
  笏披楳 竏(n,竓､)  {forall-intro}

[Test Case] 竏n. plus(0, n) = n
笨・Solved:
    笨・竓､  {true-intro}
  笏披楳 竏(n,竓､)  {forall-intro}

[Test Case] 竏n. 竏m. plus(n, S(m)) = S(plus(n, m))
笨・Solved:
      笨・竓､  {true-intro}
    笏披楳 竏(m,竓､)  {forall-intro}
  笏披楳 竏(n,竏(m,竓､))  {forall-intro}

[Test Case] 竏xs. append(xs, nil) = xs
笨・Solved:
    笨・竓､  {true-intro}
  笏披楳 竏(xs,竓､)  {forall-intro}

[Test Case] 竏xs. append(nil, xs) = xs
笨・Solved:
    笨・竓､  {true-intro}
  笏披楳 竏(xs,竓､)  {forall-intro}

[Test Case] 竏xs. 竏ys. 竏zs. append(append(xs, ys), zs) = append(xs, append(ys, zs))
笨・Solved:
        笨・竓､  {true-intro}
      笏披楳 竏(zs,竓､)  {forall-intro}
    笏披楳 竏(ys,竏(zs,竓､))  {forall-intro}
  笏披楳 竏(xs,竏(ys,竏(zs,竓､)))  {forall-intro}

[Test Case] 竏n. 竏m. plus(n, m) = plus(m, n)
笨・Solved:
      笨・竓､  {true-intro}
    笏披楳 竏(m,竓､)  {forall-intro}
        笨・竓､  {true-intro}
      笏披楳 竏(m,竓､)  {forall-intro}
            笨・竓､  {true-intro}
          笏披楳 竏(m,竓､)  {forall-intro}
        笏披楳 竏(n_0_0,竏(m,竓､))  {forall-intro}
      笏披楳 竏(n_0_0,竏(m,S(S(plus(n_0_0,m))) = S(S(plus(m,n_0_0)))))  {rewrite[IH_n_0_0]}
    笏披楳 竏(n_0,竏(m,S(plus(n_0,m)) = S(plus(m,n_0))))  {induction[Nat]}
  笏披楳 竏(n,竏(m,plus(n,m) = plus(m,n)))  {induction[Nat]}

[Test Case] 竏n. 竏m. 竏k. plus(plus(n, m), k) = plus(n, plus(m, k))
笨・Solved:
        笨・竓､  {true-intro}
      笏披楳 竏(k,竓､)  {forall-intro}
    笏披楳 竏(m,竏(k,竓､))  {forall-intro}
  笏披楳 竏(n,竏(m,竏(k,竓､)))  {forall-intro}
[success] Total time: 2 s, completed 2026/02/14 19:43:11
[info] running romanesco.Solver.SolverTests.CombinedLogicTest 
=== Combined Multi-Logic Test ===

[Test Case] G(A 竓ｸ B) 竊・(G(A) 竓ｸ G(B))
笨・Solved!
      笨・竓ｸ(G(A),G(B))  {h0}
    笏披楳 竓ｸ(G(A),G(B))  {G-dist-limplies[h0]}
  笏披楳 竊・G(竓ｸ(A,B)),竓ｸ(G(A),G(B)))  {implies-intro}

[Test Case] 笆｡(A 竓ｸ B) 竊・(笆｡A 竓ｸ 笆｡B)
笨・Solved!
      笨・笆｡(竓ｸ(A,B))  {h0}
    笏披楳 竓ｸ(笆｡(A),笆｡(B))  {modal-K-linear}
  笏披楳 竊・笆｡(竓ｸ(A,B)),竓ｸ(笆｡(A),笆｡(B)))  {implies-intro}

[Test Case] G(A * B) 竓ｸ (G(A) * G(B))
笨・Solved!
      笨・G(*(A,B))  {linear:lh0}
    笏披楳 *(G(A),G(B))  {G-dist-sepand}
  笏披楳 竓ｸ(G(*(A,B)),*(G(A),G(B)))  {linear-implies-intro}

[Test Case] 笆｡G(A 竓ｸ B) 竊・G(笆｡A 竓ｸ 笆｡B)
笨・Solved!
          笨・G(竓ｸ(A,B))  {h0}
        笏披楳 G(笆｡(竓ｸ(A,B)))  {modal-T}
      笏披楳 G(竓ｸ(笆｡(A),笆｡(B)))  {modal-K-linear}
    笏披楳 G(竓ｸ(笆｡(A),笆｡(B)))  {modal-T[h0]}
  笏披楳 竊・笆｡(G(竓ｸ(A,B))),G(竓ｸ(笆｡(A),笆｡(B))))  {implies-intro}

[Test Case] 笆｡(A * B) 竊・(笆｡A * 笆｡B)
笨・Solved!
          笨・*(A,B)  {h2}
        笏披楳 *(B,笆｡(A))  {modal-T}
      笏披楳 竊・*(A,B),*(B,笆｡(A)))  {implies-intro}
    笏披楳 竊・笆｡(*(A,B)),*(B,笆｡(A)))  {modal-T}
  笏披楳 竊・笆｡(*(A,B)),*(笆｡(A),笆｡(B)))  {modal-T}

[Test Case] G(竏x. A(x) 竓ｸ B(x)) 竊・竏x. (G(A(x)) 竓ｸ G(B(x)))
笨・Solved!
                  笨・G(竓ｸ(A(x_1),B(x_1)))  {co-induction}
                笏披楳 竓ｸ(G(A(x_1)),G(B(x_1)))  {G-dist-limplies}
              笏披楳 G(竓ｸ(A(x_1),B(x_1)))  {G-dist-limplies}
            笏披楳 X(G(竓ｸ(A(x_1),B(x_1))))  {next-step}
            笨・竓ｸ(A(x_1),B(x_1))  {h0}
          笏披楳 竏ｧ(X(G(竓ｸ(A(x_1),B(x_1)))),竓ｸ(A(x_1),B(x_1)))  {product-intro}
        笏披楳 G(竓ｸ(A(x_1),B(x_1)))  {G-expansion}
      笏披楳 竓ｸ(G(A(x_1)),G(B(x_1)))  {G-dist-limplies}
    笏披楳 竏(x,竓ｸ(G(A(x)),G(B(x))))  {forall-intro}
  笏披楳 竊・G(竏(x,竓ｸ(A(x),B(x)))),竏(x,竓ｸ(G(A(x)),G(B(x)))))  {implies-intro}

[Test Case] 竏x. 笆｡(P(x) 竓ｸ Q(x)) 竊・竏x. (笆｡P(x) 竓ｸ 笆｡Q(x))
笨・Solved!
          笨・竓ｸ(笆｡(P(x_0_3)),笆｡(Q(x_0_3)))  {h1}
        笏披楳 竏(x_0,竓ｸ(笆｡(P(x_0)),笆｡(Q(x_0))))  {forall-intro}
      笏披楳 竏(x_0,竓ｸ(笆｡(P(x_0)),笆｡(Q(x_0))))  {modal-K-linear[h1]}
    笏披楳 竊・笆｡(竓ｸ(P(x_0),Q(x_0))),竏(x_0,竓ｸ(笆｡(P(x_0)),笆｡(Q(x_0)))))  {implies-intro}
  笏披楳 竏(x,竊・笆｡(竓ｸ(P(x),Q(x))),竏(x,竓ｸ(笆｡(P(x)),笆｡(Q(x))))))  {forall-intro}
[success] Total time: 20 s, completed 2026/02/14 19:43:31
[info] running romanesco.Solver.SolverTests.runAllAdditionalTestsSuite 
============================================================
Phase 1 Additional Tests
============================================================
=== Phase 1: Advanced Arithmetic ===
[LOGGER] DISABLED
[LOGGER] Max log depth set to 10
笨・OK: Plus Commutative
笨・OK: Plus Associative

=== Phase 1: Advanced Lists ===
[LOGGER] DISABLED
[LOGGER] Max log depth set to 10
笨・OK: Append Associative
笨・OK: Reverse Reverse
笨・OK: Map Composition
============================================================

============================================================
Advanced Test Suite
============================================================
[LOGGER] DISABLED
[LOGGER] Max log depth set to 10
=== Dependent Type: Vector Tests ===
[LOGGER] DISABLED
[LOGGER] Max log depth set to 10
笨・OK: Vector head extraction
笨・OK: Vector length preservation
笨・OK: Vector map identity

=== Inductive Predicate: Graph Reachability ===
[LOGGER] DISABLED
[LOGGER] Max log depth set to 10
笨・OK: Reflexivity
笨・OK: Edge implies reach

=== Coinductive: Infinite Streams ===
[LOGGER] DISABLED
[LOGGER] Max log depth set to 5
笨・OK: Stream head of repeat
笨・OK: Stream bisimulation (self)

=== Category Theory: Monad Laws ===
[LOGGER] DISABLED
[LOGGER] Max log depth set to 5
笨・OK: List Monad: Left Identity
笨・OK: List Monad: Right Identity
笨・OK: List Monad: Associativity
笨・OK: Maybe Monad: Left Identity
笨・OK: Maybe Monad: Right Identity
笨・OK: Maybe Monad: Associativity
============================================================
[success] Total time: 6 s, completed 2026/02/14 19:43:38
[info] running romanesco.Solver.SolverTests.runPhase1TestsSuite 
============================================================
Phase 1 Additional Tests
============================================================
=== Phase 1: Advanced Arithmetic ===
[LOGGER] DISABLED
[LOGGER] Max log depth set to 10
笨・OK: Plus Commutative
笨・OK: Plus Associative

=== Phase 1: Advanced Lists ===
[LOGGER] DISABLED
[LOGGER] Max log depth set to 10
笨・OK: Append Associative
笨・OK: Reverse Reverse
笨・OK: Map Composition
============================================================
[success] Total time: 1 s, completed 2026/02/14 19:43:39
[info] running romanesco.Solver.SolverTests.runAdvancedTestsSuite 
============================================================
Advanced Test Suite
============================================================
[LOGGER] DISABLED
[LOGGER] Max log depth set to 10
=== Dependent Type: Vector Tests ===
[LOGGER] DISABLED
[LOGGER] Max log depth set to 10
笨・OK: Vector head extraction
笨・OK: Vector length preservation
笨・OK: Vector map identity

=== Inductive Predicate: Graph Reachability ===
[LOGGER] DISABLED
[LOGGER] Max log depth set to 10
笨・OK: Reflexivity
笨・OK: Edge implies reach

=== Coinductive: Infinite Streams ===
[LOGGER] DISABLED
[LOGGER] Max log depth set to 5
笨・OK: Stream head of repeat
笨・OK: Stream bisimulation (self)

=== Category Theory: Monad Laws ===
[LOGGER] DISABLED
[LOGGER] Max log depth set to 5
笨・OK: List Monad: Left Identity
笨・OK: List Monad: Right Identity
笨・OK: List Monad: Associativity
笨・OK: Maybe Monad: Left Identity
笨・OK: Maybe Monad: Right Identity
笨・OK: Maybe Monad: Associativity
============================================================
[success] Total time: 3 s, completed 2026/02/14 19:43:42
[info] running romanesco.Solver.SolverTests.HoTTAdvancedTest 
[LOGGER] DISABLED
=== HoTT Phase 1: Transport Computation Test ===
Case: transport(ﾎｻz. ﾃ・A(z), B(z)), p, pair(u, v)) = pair(transport(ﾎｻz. A(z), p, u), transport(ﾎｻz. B(z), p, v)) ... 笨・OK (Solved)
Case: transport(ﾎｻz. +(A(z), B(z)), p, inl(u)) = inl(transport(ﾎｻz. A(z), p, u)) ... 笨・OK (Solved)
Case: transport(ﾎｻz. 竊・A(z), B(z)), p, f) = ﾎｻx. transport(ﾎｻz. B(z), p, f(transport(ﾎｻz. A(z), inv(p), x))) ... 笨・OK (Solved)
Case: isProp(A) 竊・竏x:A. 竏y:A. path(A, x, y) ... 笨・OK (Solved)
Case: isProp(A) 竊・isSet(A) ... 笨・OK (Solved)
Case: (isProp(A) 竏ｧ isProp(B)) 竊・isProp(ﾃ・A, B)) ... 笨・OK (Solved)
Case: isSet(A) 竊・竏x:A. 竏y:A. 竏p:path(A, x, y). 竏q:path(A, x, y). path(path(A, x, y), p, q) ... 笨・OK (Solved)
Case: (P(zero) 竏ｧ P(one) 竏ｧ path(Type, P(zero), P(one))) 竊・竏i:Interval. P(i) ... 笨・OK (Solved)
Case: (P(north) 竏ｧ P(south) 竏ｧ 竏a. path(Type, P(north), P(south))) 竊・竏s:Susp. P(s) ... 笨・OK (Solved)
Case: comp(A, refl(x), u) = u ... 笨・OK (Solved)

=== Phase 5: Proof Mining Test ===
笨・OK: Complex arithmetic solved with dynamic lemmas

=== Phase 6: HIT DSL Test ===
笨・OK: Circle defined via DSL and induction proved
[success] Total time: 4 s, completed 2026/02/14 19:43:46
[info] running romanesco.Solver.SolverTests.UnificationAdvancedTest 
[LOGGER] DISABLED
=== Advanced Unification Test ===
[Case: Duplicate Args]
Unifying: ?1(x,x) = f(x)
笨・Solution 0: Map(1 -> ﾎｻv_0. ﾎｻv_1. f(v_0))
  Check: f(x) == f(x)
笨・Solution 1: Map(1 -> ﾎｻv_0. ﾎｻv_1. f(v_1))
  Check: f(x) == f(x)
笨・Solution 2: Map(1 -> ﾎｻv_0. ﾎｻv_1. f(x))
  Check: f(x) == f(x)
[Case: Partial Dependency]
Unifying: ?2(x,y) = f(x)
笨・Solution 0: Map(2 -> ﾎｻv_0. ﾎｻv_1. f(v_0))
  Check: f(x) == f(x)
笨・Solution 1: Map(2 -> ﾎｻv_0. ﾎｻv_1. f(x))
  Check: f(x) == f(x)
[Case: Structured Args]
Unifying: ?3(S(x)) = S(S(x))
笨・Solution 0: Map(3 -> ﾎｻv_0. S(v_0))
  Check: S(S(x)) == S(S(x))
笨・Solution 1: Map(3 -> ﾎｻv_0. S(S(x)))
  Check: S(S(x)) == S(S(x))
[Case: Nested Meta]
Unifying: ?4(x) = f(?5(x))
笨・Solution 0: Map(4 -> ﾎｻv_0. f(?5(v_0)))
  Check: f(?5(x)) == f(?5(x))
笨・Solution 1: Map(4 -> ﾎｻv_0. f(?5(x)))
  Check: f(?5(x)) == f(?5(x))
[Case: Non-deterministic Abstraction]
Unifying: ?6(x,x) = f(x,x)
笨・Solution 0: Map(6 -> ﾎｻv_0. ﾎｻv_1. f(v_0,v_0))
  Check: f(x,x) == f(x,x)
笨・Solution 1: Map(6 -> ﾎｻv_0. ﾎｻv_1. f(v_0,v_1))
  Check: f(x,x) == f(x,x)
笨・Solution 2: Map(6 -> ﾎｻv_0. ﾎｻv_1. f(v_0,x))
  Check: f(x,x) == f(x,x)
笨・Solution 3: Map(6 -> ﾎｻv_0. ﾎｻv_1. f(v_1,v_0))
  Check: f(x,x) == f(x,x)
笨・Solution 4: Map(6 -> ﾎｻv_0. ﾎｻv_1. f(v_1,v_1))
  Check: f(x,x) == f(x,x)
笨・Solution 5: Map(6 -> ﾎｻv_0. ﾎｻv_1. f(v_1,x))
  Check: f(x,x) == f(x,x)
笨・Solution 6: Map(6 -> ﾎｻv_0. ﾎｻv_1. f(x,v_0))
  Check: f(x,x) == f(x,x)
笨・Solution 7: Map(6 -> ﾎｻv_0. ﾎｻv_1. f(x,v_1))
  Check: f(x,x) == f(x,x)
笨・Solution 8: Map(6 -> ﾎｻv_0. ﾎｻv_1. f(x,x))
  Check: f(x,x) == f(x,x)
[Case: Pruning]
Unifying: ?7(x) = f(?8(x,y))
笨・Solution 0: Map(8 -> ﾎｻmv_0. ﾎｻmv_1. ?8.999(mv_0), 7 -> ﾎｻv_0. f(?8.999(v_0)))
  Check: f(?8.999(x)) == f(?8.999(x))
笨・Solution 1: Map(8 -> ﾎｻmv_0. ﾎｻmv_1. ?8.999(mv_0), 7 -> ﾎｻv_0. f(?8.999(x)))
  Check: f(?8.999(x)) == f(?8.999(x))
[success] Total time: 0 s, completed 2026/02/14 19:43:46
[info] running romanesco.Solver.SolverTests.EnhancedFrameTest 
[LOGGER] DISABLED
=== Enhanced Frame Inference Test ===
Case: Basic frame ... 笨・OK
Case: Points-to frame ... 笨・OK
Case: Multi-resource frame ... 笨・OK
Case: Minimal frame (C * D) ... 笨・OK
Case: Minimal frame (x 竊ｦ 1 * z 竊ｦ 3) ... 笨・OK
Case: Frame rule application ... 笨・OK
Case: File handle frame ... 笨・OK
Case: Lock and memory frame ... 笨・OK
[success] Total time: 6 s, completed 2026/02/14 19:43:52
[info] running romanesco.Solver.SolverTests.runMathAndVerificationTests 
=== Extended Arithmetic Verification ===
Case: plus(S(0), S(0)) = S(S(0)) ... 笨・OK
笨・竓､  {true-intro}
Case: plus(n, plus(m, k)) = plus(m, plus(n, k)) ... 笨・OK
    笨・竓､  {true-intro}
  笏披楳 plus(n,plus(m,k)) = plus(m,plus(k,n))  {plus_comm}
笏披楳 plus(n,plus(m,k)) = plus(m,plus(n,k))  {plus_comm}

=== Hoare Logic Program Verification ===
Case: {x = 1} skip {x = 1} ... 笨・OK
    笨・x = 1  {h1}
  笏披楳 竊・x = 1,x = 1)  {implies-intro}
笏披楳 triple(x = 1,skip,x = 1)  {hoare-skip}
Case: {竓､} x := 1 {x = 1} ... 笨・OK
    笨・竓､  {true-intro}
  笏披楳 竊・竓､,竓､)  {implies-intro}
笏披楳 triple(竓､,:=(x,1),x = 1)  {hoare-assign}
Case: {竓､} x := 1 ; y := 2 {x = 1 竏ｧ y = 2} ... 笨・OK
          笨・竓､  {reflexivity}
        笏披楳 竊・竓､,竓､)  {implies-intro}
      笏披楳 isProp(?3.147)  {prop-path}
    笏披楳 竊・竓､,path(?3.147,?2.5,?2.6))  {prop-path}
  笏披楳 triple(竓､,:=(x,1),path(?3.147,?2.5,?2.6))  {hoare-assign}
        笨・竓､  {reflexivity}
      笏披楳 x = 1  {rewrite[h2]}
    笏披楳 竊・path(?3.147,x,1),x = 1)  {implies-intro}
  笏披楳 triple(path(?3.147,x,1),:=(y,2),竏ｧ(x = 1,y = 2))  {hoare-assign}
笏披楳 triple(竓､,;(:=(x,1),:=(y,2)),竏ｧ(x = 1,y = 2))  {hoare-seq}
[success] Total time: 1 s, completed 2026/02/14 19:43:53
