// ==========================================
// CompilerIntegrationTest.scala
// 直接構築した AST -> 所有権推論 -> Solverによる安全性証明
// ==========================================

package romanesco.Runtime

import romanesco.Types._
import romanesco.Solver.core._

@main def CompilerIntegrationTest(): Unit =
  println("=== High-Level Memory Safety Automation Test ===")
  
  val compiler = new BytecodeCompiler()
  val optimizer = new ResourceOptimizer(new OmniResourceLogic())

  def test(name: String, tree: Tree[(String, Vector[String])]): Unit =
    println(s"\n>>> Test: $name")
    
    try {
      val rawOps = compiler.compile(tree)
      
      println("Generated Bytecode:")
      rawOps.zipWithIndex.foreach { (op, i) => println(s"  $i: $op") }
      
      println("Verifying Safety...")
      optimizer.verify(rawOps) match
        case Right(_) => 
          println("  ✓ PROOF SUCCEEDED: The code is mathematically guaranteed to be memory-safe.")
        case Left(err) => 
          println(s"  ✗ PROOF FAILED: $err")
    } catch {
      case e: Exception => 
        println(s"  ! Error: ${e.getMessage}")
        e.printStackTrace()
    }

  // --- 1. 自動借用と自動移動 (let x = 10 in x + x) ---
  // AST: Let("x", Const(10), Add(Var("x"), Var("x")))
  val test1 = Tree.V(("Let", Vector("x")), Vector(
    Tree.V(("Const", Vector("10")), Vector.empty),
    Tree.V(("Add", Vector.empty), Vector(
      Tree.V(("Var", Vector("x")), Vector.empty),
      Tree.V(("Var", Vector("x")), Vector.empty)
    ))
  ))
  test("Auto Borrow & Move", test1)

  // --- 2. 自動解放 (let x = 20 in 5) ---
  // AST: Let("x", Const(20), Const(5))
  val test2 = Tree.V(("Let", Vector("x")), Vector(
    Tree.V(("Const", Vector("20")), Vector.empty),
    Tree.V(("Const", Vector("5")), Vector.empty)
  ))
  test("Auto Free (Unused)", test2)

  // --- 3. 構造体と自動解放 (let p = (1, 2) in proj1(p)) ---
  // AST: Let("p", Pair(Const(1), Const(2)), Proj1(Var("p")))
  // Note: Proj1 はペアを消費し、r0 を返し、r1 を解放すべき
  val test3 = Tree.V(("Let", Vector("p")), Vector(
    Tree.V(("Pair", Vector.empty), Vector(
      Tree.V(("Const", Vector("1")), Vector.empty),
      Tree.V(("Const", Vector("2")), Vector.empty)
    )),
    Tree.V(("Proj1", Vector.empty), Vector(
      Tree.V(("Var", Vector("p")), Vector.empty)
    ))
  ))
  test("Auto Free (Partial Pair)", test3)

  // --- 4. ネストしたスコープ (let x = 1 in let y = 2 in x + y) ---
  val test4 = Tree.V(("Let", Vector("x")), Vector(
    Tree.V(("Const", Vector("1")), Vector.empty),
    Tree.V(("Let", Vector("y")), Vector(
      Tree.V(("Const", Vector("2")), Vector.empty),
      Tree.V(("Add", Vector.empty), Vector(
        Tree.V(("Var", Vector("x")), Vector.empty),
        Tree.V(("Var", Vector("y")), Vector.empty)
      ))
    ))
  ))
  test("Nested Scopes", test4)
