=== Romanesco Compiler (Python Port) ===
Input: C:\Users\Cocoa\romanesco\tests\08_head_selector.romanesco
Mode: <romanesco.lexing.All object at 0x0000044544597090>
Z3 Pruning: disabled
Debug mode: enabled
Evaluation: enabled

[DEBUG] pos=0: char='/' remaining='// Test 08...'
[DEBUG]   Tokenizer matched: // Test 08: Selector\n@21
[DEBUG] pos=21: char='=' remaining='= Cons (la...'
[DEBUG]   Tokenizer matched: =@22
[DEBUG] pos=22: char=' ' remaining=' Cons (lam...'
[DEBUG]   Tokenizer matched:  @23
[DEBUG] pos=23: char='C' remaining='Cons (lamb...'
[DEBUG]   Tokenizer matched: Cons@27
[DEBUG] pos=27: char=' ' remaining=' (lambda a...'
[DEBUG]   Tokenizer matched:  @28
[DEBUG] pos=28: char='(' remaining='(lambda a ...'
[DEBUG]   Tokenizer matched: (@29
[DEBUG] pos=29: char='l' remaining='lambda a (...'
[DEBUG]   Tokenizer matched: lambda@35
[DEBUG] pos=35: char=' ' remaining=' a (lambda...'
[DEBUG]   Tokenizer matched:  @36
[DEBUG] pos=36: char='a' remaining='a (lambda ...'
[DEBUG]   Tokenizer matched: a@37
[DEBUG] pos=37: char=' ' remaining=' (lambda b...'
[DEBUG]   Tokenizer matched:  @38
[DEBUG] pos=38: char='(' remaining='(lambda b ...'
[DEBUG]   Tokenizer matched: (@39
[DEBUG] pos=39: char='l' remaining='lambda b (...'
[DEBUG]   Tokenizer matched: lambda@45
[DEBUG] pos=45: char=' ' remaining=' b (and a ...'
[DEBUG]   Tokenizer matched:  @46
[DEBUG] pos=46: char='b' remaining='b (and a b...'
[DEBUG]   Tokenizer matched: b@47
[DEBUG] pos=47: char=' ' remaining=' (and a b)...'
[DEBUG]   Tokenizer matched:  @48
[DEBUG] pos=48: char='(' remaining='(and a b))...'
[DEBUG]   Tokenizer matched: (@49
[DEBUG] pos=49: char='a' remaining='and a b)))...'
[DEBUG]   Tokenizer matched: and@52
[DEBUG] pos=52: char=' ' remaining=' a b)))\n= ...'
[DEBUG]   Tokenizer matched:  @53
[DEBUG] pos=53: char='a' remaining='a b)))\n= N...'
[DEBUG]   Tokenizer matched: a@54
[DEBUG] pos=54: char=' ' remaining=' b)))\n= Ni...'
[DEBUG]   Tokenizer matched:  @55
[DEBUG] pos=55: char='b' remaining='b)))\n= Nil...'
[DEBUG]   Tokenizer matched: b@56
[DEBUG] pos=56: char=')' remaining=')))\n= Nil ...'
[DEBUG]   Tokenizer matched: )@57
[DEBUG] pos=57: char=')' remaining='))\n= Nil t...'
[DEBUG]   Tokenizer matched: )@58
[DEBUG] pos=58: char=')' remaining=')\n= Nil tr...'
[DEBUG]   Tokenizer matched: )@59
[DEBUG] pos=59: char='\n' remaining='\n= Nil tru...'
[DEBUG]   Tokenizer matched: \n@60
[DEBUG] pos=60: char='=' remaining='= Nil true...'
[DEBUG]   Tokenizer matched: =@61
[DEBUG] pos=61: char=' ' remaining=' Nil true\n...'
[DEBUG]   Tokenizer matched:  @62
[DEBUG] pos=62: char='N' remaining='Nil true\n=...'
[DEBUG]   Tokenizer matched: Nil@65
[DEBUG] pos=65: char=' ' remaining=' true\n= my...'
[DEBUG]   Tokenizer matched:  @66
[DEBUG] pos=66: char='t' remaining='true\n= myL...'
[DEBUG]   Tokenizer matched: true@70
[DEBUG] pos=70: char='\n' remaining='\n= myList ...'
[DEBUG]   Tokenizer matched: \n@71
[DEBUG] pos=71: char='=' remaining='= myList (...'
[DEBUG]   Tokenizer matched: =@72
[DEBUG] pos=72: char=' ' remaining=' myList (C...'
[DEBUG]   Tokenizer matched:  @73
[DEBUG] pos=73: char='m' remaining='myList (Co...'
[DEBUG]   Tokenizer matched: myList@79
[DEBUG] pos=79: char=' ' remaining=' (Cons 1 (...'
[DEBUG]   Tokenizer matched:  @80
[DEBUG] pos=80: char='(' remaining='(Cons 1 (C...'
[DEBUG]   Tokenizer matched: (@81
[DEBUG] pos=81: char='C' remaining='Cons 1 (Co...'
[DEBUG]   Tokenizer matched: Cons@85
[DEBUG] pos=85: char=' ' remaining=' 1 (Cons 2...'
[DEBUG]   Tokenizer matched:  @86
[DEBUG] pos=86: char='1' remaining='1 (Cons 2 ...'
[DEBUG]   Tokenizer matched: 1@87
[DEBUG] pos=87: char=' ' remaining=' (Cons 2 N...'
[DEBUG]   Tokenizer matched:  @88
[DEBUG] pos=88: char='(' remaining='(Cons 2 Ni...'
[DEBUG]   Tokenizer matched: (@89
[DEBUG] pos=89: char='C' remaining='Cons 2 Nil...'
[DEBUG]   Tokenizer matched: Cons@93
[DEBUG] pos=93: char=' ' remaining=' 2 Nil))\n=...'
[DEBUG]   Tokenizer matched:  @94
[DEBUG] pos=94: char='2' remaining='2 Nil))\n= ...'
[DEBUG]   Tokenizer matched: 2@95
[DEBUG] pos=95: char=' ' remaining=' Nil))\n= h...'
[DEBUG]   Tokenizer matched:  @96
[DEBUG] pos=96: char='N' remaining='Nil))\n= he...'
[DEBUG]   Tokenizer matched: Nil@99
[DEBUG] pos=99: char=')' remaining='))\n= head ...'
[DEBUG]   Tokenizer matched: )@100
[DEBUG] pos=100: char=')' remaining=')\n= head l...'
[DEBUG]   Tokenizer matched: )@101
[DEBUG] pos=101: char='\n' remaining='\n= head la...'
[DEBUG]   Tokenizer matched: \n@102
[DEBUG] pos=102: char='=' remaining='= head lam...'
[DEBUG]   Tokenizer matched: =@103
[DEBUG] pos=103: char=' ' remaining=' head lamb...'
[DEBUG]   Tokenizer matched:  @104
[DEBUG] pos=104: char='h' remaining='head lambd...'
[DEBUG]   Tokenizer matched: head@108
[DEBUG] pos=108: char=' ' remaining=' lambda ls...'
[DEBUG]   Tokenizer matched:  @109
[DEBUG] pos=109: char='l' remaining='lambda lst...'
[DEBUG]   Tokenizer matched: lambda@115
[DEBUG] pos=115: char=' ' remaining=' lst {\n  =...'
[DEBUG]   Tokenizer matched:  @116
[DEBUG] pos=116: char='l' remaining='lst {\n  = ...'
[DEBUG]   Tokenizer matched: lst@119
[DEBUG] pos=119: char=' ' remaining=' {\n  = lst...'
[DEBUG]   Tokenizer matched:  @120
[DEBUG] pos=120: char='{' remaining='{\n  = lst ...'
[DEBUG]   Tokenizer matched: {@121
[DEBUG] pos=121: char='\n' remaining='\n  = lst (...'
[DEBUG]   Tokenizer matched: \n  @124
[DEBUG] pos=124: char='=' remaining='= lst (Con...'
[DEBUG]   Tokenizer matched: =@125
[DEBUG] pos=125: char=' ' remaining=' lst (Cons...'
[DEBUG]   Tokenizer matched:  @126
[DEBUG] pos=126: char='l' remaining='lst (Cons ...'
[DEBUG]   Tokenizer matched: lst@129
[DEBUG] pos=129: char=' ' remaining=' (Cons fir...'
[DEBUG]   Tokenizer matched:  @130
[DEBUG] pos=130: char='(' remaining='(Cons firs...'
[DEBUG]   Tokenizer matched: (@131
[DEBUG] pos=131: char='C' remaining='Cons first...'
[DEBUG]   Tokenizer matched: Cons@135
[DEBUG] pos=135: char=' ' remaining=' first res...'
[DEBUG]   Tokenizer matched:  @136
[DEBUG] pos=136: char='f' remaining='first rest...'
[DEBUG]   Tokenizer matched: first@141
[DEBUG] pos=141: char=' ' remaining=' rest)\n  f...'
[DEBUG]   Tokenizer matched:  @142
[DEBUG] pos=142: char='r' remaining='rest)\n  fi...'
[DEBUG]   Tokenizer matched: rest@146
[DEBUG] pos=146: char=')' remaining=')\n  first\n...'
[DEBUG]   Tokenizer matched: )@147
[DEBUG] pos=147: char='\n' remaining='\n  first\n}...'
[DEBUG]   Tokenizer matched: \n  @150
[DEBUG] pos=150: char='f' remaining='first\n}\n= ...'
[DEBUG]   Tokenizer matched: first@155
[DEBUG] pos=155: char='\n' remaining='\n}\n= resul...'
[DEBUG]   Tokenizer matched: \n@156
[DEBUG] pos=156: char='}' remaining='}\n= result...'
[DEBUG]   Tokenizer matched: }@157
[DEBUG] pos=157: char='\n' remaining='\n= result ...'
[DEBUG]   Tokenizer matched: \n@158
[DEBUG] pos=158: char='=' remaining='= result (...'
[DEBUG]   Tokenizer matched: =@159
[DEBUG] pos=159: char=' ' remaining=' result (h...'
[DEBUG]   Tokenizer matched:  @160
[DEBUG] pos=160: char='r' remaining='result (he...'
[DEBUG]   Tokenizer matched: result@166
[DEBUG] pos=166: char=' ' remaining=' (head myL...'
[DEBUG]   Tokenizer matched:  @167
[DEBUG] pos=167: char='(' remaining='(head myLi...'
[DEBUG]   Tokenizer matched: (@168
[DEBUG] pos=168: char='h' remaining='head myLis...'
[DEBUG]   Tokenizer matched: head@172
[DEBUG] pos=172: char=' ' remaining=' myList)\nr...'
[DEBUG]   Tokenizer matched:  @173
[DEBUG] pos=173: char='m' remaining='myList)\nre...'
[DEBUG]   Tokenizer matched: myList@179
[DEBUG] pos=179: char=')' remaining=')\nresult\n...'
[DEBUG]   Tokenizer matched: )@180
[DEBUG] pos=180: char='\n' remaining='\nresult\n...'
[DEBUG]   Tokenizer matched: \n@181
[DEBUG] pos=181: char='r' remaining='result\n...'
[DEBUG]   Tokenizer matched: result@187
[DEBUG] pos=187: char='\n' remaining='\n...'
[DEBUG]   Tokenizer matched: \n@188
[DEBUG] pos=188: Reached end of input
[DEBUG]   Tokenizer matched: and@52
[DEBUG]   Tokenizer matched: /@1
[DEBUG] pos=1: char='/' remaining='/ Test 08:...'
[DEBUG]   Tokenizer matched: /@2
[DEBUG] pos=2: char=' ' remaining=' Test 08: ...'
[DEBUG]   Tokenizer matched:  @3
[DEBUG] pos=3: char='T' remaining='Test 08: S...'
[DEBUG]   Tokenizer matched: Test@7
[DEBUG] pos=7: char=' ' remaining=' 08: Selec...'
[DEBUG]   Tokenizer matched:  @8
[DEBUG] pos=8: char='0' remaining='08: Select...'
[DEBUG]   Tokenizer matched: 08@10
[DEBUG] pos=10: char=':' remaining=': Selector...'
[DEBUG]   Tokenizer matched: :@11
[DEBUG] pos=11: char=' ' remaining=' Selector\n...'
[DEBUG]   Tokenizer matched:  @12
[DEBUG] pos=12: char='S' remaining='Selector\n=...'
[DEBUG]   Tokenizer matched: Selector@20
[DEBUG] pos=20: char='\n' remaining='\n= Cons (l...'
[DEBUG]   Tokenizer matched: \n@21
 @0x445448a5d10
„¥„Ÿ„Ÿ WS(// Test 08: Selector
) @0x445448a54d0 ->  @0x445448a5470 -> Op(=) @0x445448a5410 ->  @0x445448a53b0 -> WS( ) @0x445448a5350 ->  @0x445448a52f0 -> Ident(Cons) @0x445448a5290 ->  @0x445448a5230 -> WS( ) @0x445448a51d0 ->  @0x445448a5170 -> Delim(() @0x445448a5110 ->  @0x445448a50b0 -> Ident(lambda) @0x445448a5050 ->  @0x445448a4ff0 -> WS( ) @0x445448a4f90 ->  @0x445448a4f30 -> Ident(a) @0x445448a4ed0 ->  @0x445448a4e70 -> WS( ) @0x445448a4e10 ->  @0x445448a4db0 -> Delim(() @0x445448a4d50 ->  @0x445448a4cf0 -> Ident(lambda) @0x445448a4c90 ->  @0x445448a4c30 -> WS( ) @0x445448a4bd0 ->  @0x445448a4b70 -> Ident(b) @0x445448a4b10 ->  @0x445448a4ab0 -> WS( ) @0x445448a4a50 ->  @0x445448a49f0 -> Delim(() @0x445448a4990 ->  @0x445448a4930
„    „¥„Ÿ„Ÿ Op(and) @0x445448a4870 ->  @0x445448a4810 -> WS( ) @0x445448a47b0 ->  @0x445448a4750 -> Ident(a) @0x445448a46f0 ->  @0x445448a4690 -> WS( ) @0x445448a4630 ->  @0x445448a45d0 -> Ident(b) @0x445448a4570 ->  @0x445448a4510 -> Delim()) @0x445448a44b0 ->  @0x445448a4450 -> Delim()) @0x445448a43f0 ->  @0x445448a4390 -> Delim()) @0x445448a4330 ->  @0x445448a42d0 -> WS(
) @0x445448a4270 ->  @0x445448a4210 -> Op(=) @0x445448a41b0 ->  @0x445448a4150 -> WS( ) @0x445448a40f0 ->  @0x445448a4090 -> Ident(Nil) @0x445448a4030 ->  @0x445448a3fd0 -> WS( ) @0x445448a3f70 ->  @0x445448a3f10 -> Ident(true) @0x445448a3eb0 ->  @0x445448a3e50 -> WS(
) @0x445448a3df0 ->  @0x445448a3d90 -> Op(=) @0x445448a3d30 ->  @0x445448a3cd0 -> WS( ) @0x445448a3c70 ->  @0x445448a3c10 -> Ident(myList) @0x445448a3bb0 ->  @0x445448a3b50 -> WS( ) @0x445448a3af0 ->  @0x445448a3a90 -> Delim(() @0x445448a3a30 ->  @0x445448a39d0 -> Ident(Cons) @0x445448a3970 ->  @0x445448a3910 -> WS( ) @0x445448a38b0 ->  @0x445448a3850 -> Number(1) @0x445448a37f0 ->  @0x445448a3790 -> WS( ) @0x445448a3730 ->  @0x445448a36d0 -> Delim(() @0x445448a3670 ->  @0x445448a3610 -> Ident(Cons) @0x445448a35b0 ->  @0x445448a3550 -> WS( ) @0x445448a34f0 ->  @0x445448a3490 -> Number(2) @0x445448a3430 ->  @0x445448a33d0 -> WS( ) @0x445448a3370 ->  @0x445448a3310 -> Ident(Nil) @0x445448a32b0 ->  @0x445448a3250 -> Delim()) @0x445448a31f0 ->  @0x445448a3190 -> Delim()) @0x445448a3130 ->  @0x445448a30d0 -> WS(
) @0x445448a3070 ->  @0x445448a3010 -> Op(=) @0x445448a2fb0 ->  @0x445448a2b30 -> WS( ) @0x445448a2830 ->  @0x445448a2b90 -> Ident(head) @0x445448a2bf0 ->  @0x445448a2a10 -> WS( ) @0x445448a2ad0 ->  @0x445448a29b0 -> Ident(lambda) @0x445448a0d30 ->  @0x445448a1210 -> WS( ) @0x445448a2050 ->  @0x445448a1b70 -> Ident(lst) @0x445448a1030 ->  @0x445448a1e70 -> WS( ) @0x445448a19f0 ->  @0x445448a20b0 -> Delim({) @0x445448a2110 ->  @0x445448a0c10 -> WS(
  ) @0x445448a1d50 ->  @0x445448a1810 -> Op(=) @0x445448a0250 ->  @0x445448a1270 -> WS( ) @0x445448a0850 ->  @0x445448a2dd0 -> Ident(lst) @0x445448a2e30 ->  @0x445448a2ef0 -> WS( ) @0x445448a2d70 ->  @0x445448a2c50 -> Delim(() @0x445448a1510 ->  @0x445448a1630 -> Ident(Cons) @0x445448a2cb0 ->  @0x445448a14b0 -> WS( ) @0x445448a1ff0 ->  @0x445448a2890 -> Ident(first) @0x445448a2710 ->  @0x445448a22f0 -> WS( ) @0x445448a26b0 ->  @0x445448a2770 -> Ident(rest) @0x445448a25f0 ->  @0x445448a0430 -> Delim()) @0x445448a07f0 ->  @0x445448a0730 -> WS(
  ) @0x445448a2470 ->  @0x445448a2350 -> Ident(first) @0x445448a27d0 ->  @0x445448a21d0 -> WS(
) @0x445448a2230 ->  @0x445448a24d0 -> Delim(}) @0x445448a2170 ->  @0x445448a23b0 -> WS(
) @0x445455c6980 ->  @0x445455c6910 -> Op(=) @0x44544880510 ->  @0x44544880e90 -> WS( ) @0x44544736690 ->  @0x445447365f0 -> Ident(result) @0x44544736550 ->  @0x445447f1d50 -> WS( ) @0x445447f1c90 ->  @0x445447f1bd0 -> Delim(() @0x445447f1b10 ->  @0x445446f15f0 -> Ident(head) @0x445446f16d0 ->  @0x445446f1f90 -> WS( ) @0x445455a2910 ->  @0x445455a2810 -> Ident(myList) @0x445455a2710 ->  @0x445455a2610 -> Delim()) @0x445445aa010 ->  @0x445445a9ed0 -> WS(
) @0x445445a9d90 ->  @0x445445a9c50 -> Ident(result) @0x445445a9b10 ->  @0x445445a99d0 -> WS(
) @0x445445a9890 ->  @0x44544597b10
„    „¤„Ÿ„Ÿ Ident(and) @0x445448a48d0 -> (ref: @0x445448a4810)
„¤„Ÿ„Ÿ Op(/) @0x445448a5cb0 ->  @0x445448a5c50 -> Op(/) @0x445448a5bf0 ->  @0x445448a5b90 -> WS( ) @0x445448a5b30 ->  @0x445448a5ad0 -> Ident(Test) @0x445448a5a70 ->  @0x445448a5a10 -> WS( ) @0x445448a59b0 ->  @0x445448a5950 -> Number(08) @0x445448a58f0 ->  @0x445448a5890 -> Delim(:) @0x445448a5830 ->  @0x445448a57d0 -> WS( ) @0x445448a5770 ->  @0x445448a5710 -> Ident(Selector) @0x445448a56b0 ->  @0x445448a5650 -> WS(
) @0x445448a55f0 -> (ref: @0x445448a5470)

== Lexing (before pruning) ==
  Found 4 token sequences
  Time: 1ms

== Lexing (final) ==
  Path 0: = Cons ( lambda a ( lambda b ( and a b ) ) ) = Nil true = myList ( Cons 1 ( Cons 2 Nil ) ) = head lambda lst { = lst ( Cons first rest ) first } = result ( head myList ) result
  Path 1: = Cons ( lambda a ( lambda b ( and a b ) ) ) = Nil true = myList ( Cons 1 ( Cons 2 Nil ) ) = head lambda lst { = lst ( Cons first rest ) first } = result ( head myList ) result
  Path 2: / / Test 08 : Selector = Cons ( lambda a ( lambda b ( and a b ) ) ) = Nil true = myList ( Cons 1 ( Cons 2 Nil ) ) = head lambda lst { = lst ( Cons first rest ) first } = result ( head myList ) result
  Path 3: / / Test 08 : Selector = Cons ( lambda a ( lambda b ( and a b ) ) ) = Nil true = myList ( Cons 1 ( Cons 2 Nil ) ) = head lambda lst { = lst ( Cons first rest ) first } = result ( head myList ) result
  Time: 1ms
  Found 4 token sequences

[REWRITE] Starting Rewriting Engine with 50 tokens
[REWRITE] Parsing expr at 0: =
[REWRITE] Parsing expr at 1: Cons
[REWRITE] Parsing expr at 2: (
[REWRITE] Parsing expr at 3: lambda
[REWRITE] Parsing expr at 5: (
[REWRITE] Parsing expr at 6: lambda
[REWRITE] Parsing expr at 8: (
[REWRITE] Parsing expr at 9: and
[REWRITE] Parsing expr at 10: a
[REWRITE] Parsing expr at 11: b
[REWRITE] Parsed Stmt: Call(Var(=), [Var(Cons), Call(Lambda(a, Call(Lambda(b, Call(Call(Var(and), [Var(a), Var(b)]), [])), [])), [])])
[REWRITE] Parsing expr at 15: =
[REWRITE] Parsing expr at 16: Nil
[REWRITE] Parsing expr at 17: true
[REWRITE] Parsed Stmt: Call(Var(=), [Var(Nil), Var(true)])
[REWRITE] Parsing expr at 18: =
[REWRITE] Parsing expr at 19: myList
[REWRITE] Parsing expr at 20: (
[REWRITE] Parsing expr at 21: Cons
[REWRITE] Parsing expr at 22: 1
[REWRITE] Parsing expr at 23: (
[REWRITE] Parsing expr at 24: Cons
[REWRITE] Parsing expr at 25: 2
[REWRITE] Parsing expr at 26: Nil
[REWRITE] Parsed Stmt: Call(Var(=), [Var(myList), Call(Var(Cons), [Num(1), Call(Var(Cons), [Num(2), Var(Nil)])])])
[REWRITE] Parsing expr at 29: =
[REWRITE] Parsing expr at 30: head
[REWRITE] Parsing expr at 31: lambda
[REWRITE] Parsing expr at 33: {
[REWRITE] Parsing expr at 34: =
[REWRITE] Parsing expr at 35: lst
[REWRITE] Parsing expr at 36: (
[REWRITE] Parsing expr at 37: Cons
[REWRITE] Parsing expr at 38: first
[REWRITE] Parsing expr at 39: rest
[REWRITE] Parsing expr at 41: first
[REWRITE] Parsed Stmt: Call(Var(=), [Var(head), Lambda(lst, Block([Call(Var(=), [Var(lst), Call(Var(Cons), [Var(first), Var(rest)])]), Var(first)]))])
[REWRITE] Parsing expr at 43: =
[REWRITE] Parsing expr at 44: result
[REWRITE] Parsing expr at 45: (
[REWRITE] Parsing expr at 46: head
[REWRITE] Parsing expr at 47: myList
[REWRITE] Parsed Stmt: Call(Var(=), [Var(result), Call(Var(head), [Var(myList)])])
[REWRITE] Parsing expr at 49: result
[REWRITE] Parsed Stmt: Var(result)
== Parsing ==
  Parse 0:
    [Call(Var(=), [Var(Cons), Call(Lambda(a, Call(Lambda(b, Call(Call(Var(and), [Var(a), Var(b)]), [])), [])), [])]), Call(Var(=), [Var(Nil), Var(true)]), Call(Var(=), [Var(myList), Call(Var(Cons), [Num(1), Call(Var(Cons), [Num(2), Var(Nil)])])]), Call(Var(=), [Var(head), Lambda(lst, Block([Call(Var(=), [Var(lst), Call(Var(Cons), [Var(first), Var(rest)])]), Var(first)]))]), Call(Var(=), [Var(result), Call(Var(head), [Var(myList)])]), Var(result)]
  Time: 1ms
  Found 1 parse trees

== Evaluation (Path 0) ==
[INFER] Starting Bit-Width Inference with Optimization
[INFER] Inference Successful: {'a': 0, 'b': 0, 'Cons': 0, 'true': 0, 'Nil': 0, 'myList': 2, 'lst': 0, 'first': 0, 'rest': 0, 'head': 0, 'result': 2}
[EVAL] --- Stmt 0 ---
[EVAL] Apply: <=> applied to Atom(Cons)
[EVAL] Apply: PartialBinOp(op='=', left_val=Atom(Cons), right_expr=None) applied to Apply(Apply(Atom(lambda), Atom(a)), Apply(Apply(Atom(lambda), Atom(b)), Apply(Apply(Atom(and), Atom(a)), Atom(b))))
[EVAL] Apply: <lambda> applied to Atom(a)
[EVAL] Apply: <lambda a> applied to Apply(Apply(Atom(lambda), Atom(b)), Apply(Apply(Atom(and), Atom(a)), Atom(b)))
[EVAL]   -> Defined Closure: lambda a ...
[EVAL] Free Atom Cons: Creating pattern/logic variable
[EVAL] Unifying: Cons <-> <lambda a>
[EVAL]   -> Matching atom pattern Cons to <lambda a>
[EVAL] --- Stmt 1 ---
[EVAL] Apply: <=> applied to Atom(Nil)
[EVAL] Apply: PartialBinOp(op='=', left_val=Atom(Nil), right_expr=None) applied to Atom(true)
[EVAL] Free Atom Nil: Creating pattern/logic variable
[EVAL] Unifying: Nil <-> true
[EVAL]   -> Matching atom pattern Nil to true
[EVAL] --- Stmt 2 ---
[EVAL] Apply: <=> applied to Atom(myList)
[EVAL] Apply: PartialBinOp(op='=', left_val=Atom(myList), right_expr=None) applied to Apply(Apply(Atom(Cons), Atom(1)), Apply(Apply(Atom(Cons), Atom(2)), Atom(Nil)))
[EVAL] Lookup Cons: Found <lambda a>
[EVAL] Apply: <lambda a> applied to Atom(1)
[EVAL] Literal 1: val=1, bit_width=1
[EVAL]   -> Calling Closure a with 1
[EVAL] Apply: <lambda> applied to Atom(b)
[EVAL] Apply: <lambda b> applied to Apply(Apply(Atom(and), Atom(a)), Atom(b))
[EVAL]   -> Defined Closure: lambda b ...
[EVAL] Apply: <lambda b> applied to Apply(Apply(Atom(Cons), Atom(2)), Atom(Nil))
[EVAL] Lookup Cons: Found <lambda a>
[EVAL] Apply: <lambda a> applied to Atom(2)
[EVAL] Literal 2: val=2, bit_width=2
[EVAL]   -> Calling Closure a with 2
[EVAL] Apply: <lambda> applied to Atom(b)
[EVAL] Apply: <lambda b> applied to Apply(Apply(Atom(and), Atom(a)), Atom(b))
[EVAL]   -> Defined Closure: lambda b ...
[EVAL] Apply: <lambda b> applied to Atom(Nil)
[EVAL] Lookup Nil: Found true
[EVAL]   -> Calling Closure b with true
[EVAL] Apply: <and> applied to Atom(a)
[EVAL] Lookup a: Found 1
[EVAL] Apply: PartialBinOp(op='and', left_val=IntVal(val=1, width=1), right_expr=None) applied to Atom(b)
[EVAL] Lookup b: Found true
[EVAL]   -> Primitive and Result: (1, true)
[EVAL]   -> Calling Closure b with (1, true)
[EVAL] Apply: <and> applied to Atom(a)
[EVAL] Lookup a: Found 1
[EVAL] Apply: PartialBinOp(op='and', left_val=IntVal(val=1, width=1), right_expr=None) applied to Atom(b)
[EVAL] Lookup b: Found true
[EVAL]   -> Primitive and Result: (1, true)
[EVAL] Free Atom myList: Creating pattern/logic variable
[EVAL] Unifying: myList <-> (1, true)
[EVAL]   -> Matching atom pattern myList to (1, true)
[EVAL] --- Stmt 3 ---
[EVAL] Apply: <=> applied to Atom(head)
[EVAL] Apply: PartialBinOp(op='=', left_val=Atom(head), right_expr=None) applied to Apply(Apply(Atom(lambda), Atom(lst)), Apply(Apply(Atom(seq), Apply(Apply(Atom(=), Atom(lst)), Apply(Apply(Atom(Cons), Atom(first)), Atom(rest)))), Atom(first)))
[EVAL] Apply: <lambda> applied to Atom(lst)
[EVAL] Apply: <lambda lst> applied to Apply(Apply(Atom(seq), Apply(Apply(Atom(=), Atom(lst)), Apply(Apply(Atom(Cons), Atom(first)), Atom(rest)))), Atom(first))
[EVAL]   -> Defined Closure: lambda lst ...
[EVAL] Free Atom head: Creating pattern/logic variable
[EVAL] Unifying: head <-> <lambda lst>
[EVAL]   -> Matching atom pattern head to <lambda lst>
[EVAL] --- Stmt 4 ---
[EVAL] Apply: <=> applied to Atom(result)
[EVAL] Apply: PartialBinOp(op='=', left_val=Atom(result), right_expr=None) applied to Apply(Atom(head), Atom(myList))
[EVAL] Lookup head: Found <lambda lst>
[EVAL] Apply: <lambda lst> applied to Atom(myList)
[EVAL] Lookup myList: Found (1, true)
[EVAL]   -> Calling Closure lst with (1, true)
[EVAL] Apply: <seq> applied to Apply(Apply(Atom(=), Atom(lst)), Apply(Apply(Atom(Cons), Atom(first)), Atom(rest)))
[EVAL] Apply: <=> applied to Atom(lst)
[EVAL] Apply: PartialBinOp(op='=', left_val=Atom(lst), right_expr=None) applied to Apply(Apply(Atom(Cons), Atom(first)), Atom(rest))
[EVAL] Lookup Cons: Found <lambda a>
[EVAL] Apply: <lambda a> applied to Atom(first)
[EVAL] Free Atom first: Creating pattern/logic variable
[EVAL]   -> Calling Closure a with first
[EVAL] Apply: <lambda> applied to Atom(b)
[EVAL] Apply: <lambda b> applied to Apply(Apply(Atom(and), Atom(a)), Atom(b))
[EVAL]   -> Defined Closure: lambda b ...
[EVAL] Apply: <lambda b> applied to Atom(rest)
[EVAL] Free Atom rest: Creating pattern/logic variable
[EVAL]   -> Calling Closure b with rest
[EVAL] Apply: <and> applied to Atom(a)
[EVAL] Lookup a: Found 1
[EVAL] Apply: PartialBinOp(op='and', left_val=IntVal(val=1, width=1), right_expr=None) applied to Atom(b)
[EVAL] Lookup b: Found true
[EVAL]   -> Primitive and Result: (1, true)
[EVAL] Lookup lst: Found (1, true)
[EVAL] Unifying: (1, true) <-> (1, true)
[EVAL]   -> Values are equal
[EVAL] Apply: PartialBinOp(op='seq', left_val=None, right_expr=None) applied to Atom(first)
[EVAL] Free Atom first: Creating pattern/logic variable
[EVAL] Free Atom result: Creating pattern/logic variable
[EVAL] Unifying: result <-> first
[EVAL]   -> Matching atom pattern result to first
[EVAL] --- Stmt 5 ---
[EVAL] Lookup result: Found first
  Found 1 possible solutions:
  --- Solution 0 ---
Result: first
  Time: 52ms


Total time: 58ms
