# Romanesco 言語設計思想：究極の疎結合と自己進化

## 1. 第一級環境と汎用プロパティシステム

Romanesco の中核は、単なる名前解決を超えた **「プロパティ付きシンボルテーブル（SymbolTable）」** にある。

### 概念の抽象化
- **非ハードコード設計**: 言語コア（Parser/Lexer）は「マクロ」という特定の概念を直接持たない。
- **メタデータのデータ化**: ある関数が AST 変換を行うか、事前計算を行うかといった情報は、シンボルに付与された `"phase" -> "ast"` などの汎用プロパティとして管理される。
- **ステートレス展開**: `Expander` はグローバルな状態を持たず、現在のスコープに定義されたプロパティに従って動的に展開を制御する。

## 2. 第一級パーサー (First-class Parser)

Romanesco では、関数（Apply）自身が **「自分がどのように読み込まれるべきか」** というパース戦略を保持できる。

### パース戦略の委譲
- `Apply` ノードはオプションで `CustomParser` を持つ。
- パーサー（`rParser`）は、シンボルを見つけた際、その定義に `CustomParser` があれば、引数のパース権限を即座にそのオブジェクトへ委譲する。
- **実用例**: `macro-char` はこの仕組みを利用し、第 1 引数を「評価前の生のトークン」として読み取らせることで、既にマクロ化された記号の安全な再定義（自己書き換え）を可能にしている。

## 3. 反復パースによる構文の動的進化 (Fixed-point Parsing)

Romanesco は、実行中に自身の字句規則を書き換え、即座に自分自身を読み直す能力を持つ。

- **動的区切り文字（Delimiter）**: `(` や `)` を含む全ての区切り文字は、`LexerTable` で管理される。
- **自動リレキシング**: 実行によって `LexerTable` が変化すると、処理系は自動的にソースコードを最新の規則でトークン化し直す。これにより、`macro-char '` の実行直後から `'hello` といった空白なしの記述が可能になる。

## 4. 盤石な衛生性と依存関係グラフ

マクロによる意図しない名前の衝突を排除するため、厳格な衛生性モデルを採用している。

- **出生地（Birth Scope）の刻印**: 全てのノードは生成時の `ScopeID` を保持する。
- **二段階解決**: 名前解決は、まず出生スコープで装飾された名前（マングリング）を優先し、次に正当な祖先スコープを遡る。
- **検証フェーズ**: `Validator` は、評価前に AST を静的に解析し、全ての識別子が衛生性ルールに則って一意に解決可能かを一括検証する。

## 5. 極限の同図像性

- **トークンの統一**: 全てのトークンは `TWord` に統合された。
- **純粋なパーツ**: 言語は `Apply` と `Atom` という 2 つのパーツのみで構成され、文法の拡張やメタプログラミングも全てこの「適用」の枠組みの中で表現される。
- **計算の定義**: 言語自身が自身の環境（プロパティ、パース戦略、規則）を編集し続けるプロセスそのものが「計算」である。
