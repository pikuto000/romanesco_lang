# Romanesco 言語設計思想とマクロ構想

## 1. 基本記号の意味論 (Semantics of Core Symbols)

Romanesco では、計算を単なる値の簡約ではなく、制約の解決と項の導出のプロセスとして捉える。

- **`\` (Lambda)**: 構造の抽象化。3引数を取り、`\ Arg Expr ApplyArg` の形式で記述する。
    - `ApplyArg` に値を渡すと即時実行 (IIFE) される。
    - `ApplyArg` に `_` を渡すと、関数オブジェクト（クロージャ）を返す。
- **`:-` (Clause)**: 名前、制約（Constraint）、実体の紐付け。
- **`_` (Wildcard)**:
    - `:-` における「制約なし」。
    - `\` における「部分適用（適用の延期）」。
    - 組み込み演算子（`+`, `-` 等）の引数における「部分適用」。例: `+ 1 _` は `x => 1 + x` を返す。
- **`?` (Term)**: 「導出・解決されるべき変数」。Prolog の論理変数に近く、式を成立させるための能動的な空白を表す。トップレベルで未解決の `?` が残っている場合はエラーとなる。

## 2. 静的制約型付け (Static Constraint Typing)

- `:- Name Constraint Expr` の形式を取り、`Constraint` 部に具体的な式を記述することで、型を自由に制限できる。
- 将来的には Scala 実装であることを活かし、SMT ソルバー（Z3 等）を導入して、これらの制約をコンパイル時に検証・解決することを検討している。

## 3. コンパイル時メタプログラミング (Macro System)

Romanesco のマクロは、単なるコードの置き換えを超え、言語そのものを全く別のものに変容させる力を持つ。

### アーキテクチャの階層
1.  **リーダー・マクロ (Token Level)**:
    - 文字レベル、トークン制御レベルから制御をマクロに委譲する。
    - これにより、空白区切り以外の構文（インデントベース、中括弧ベースなど）を自由に取り込める。
2.  **構文トランスフォーマー (Structural Level)**:
    - `Apply` ノードのツリーをデータ構造として受け取り、別の構造へ書き換える。
    - 「適用そのものをデータとして扱える」という同図像性の真価を発揮する。
3.  **事前計算レイヤー (Compile-time Eval)**:
    - コンパイル時に実行可能なコードを評価し、定数畳み込みや最適化を行う。

### 実行フェーズ
- **Stage 0**: 生テキストの読み込み。
- **Stage 1**: リーダー・マクロによるトークン制御の書き換え。
- **Stage 2**: 構造的なマクロ展開（AST 変換）。
- **Stage 3**: 静的制約の検証（SMT ソルバー等）。
- **Stage 4**: 実行時評価。

## 4. 構文の特徴

- **固定アリティと動的登録**:
    `:-` によって関数が定義された際、シンボルテーブル上でその名前は自動的に適切なアリティ（引数数）を持つオペレータとして登録される。これにより、括弧を使わない自然な前置記法（`f x`）が可能となる。
- **純粋な評価器**:
    インタプリタ (`eval`) は特定の演算子に対する特例処理を持たず、全ての振る舞い（部分適用など）は関数自身のロジックとして実装されている。
