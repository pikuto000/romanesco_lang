# Romanesco 言語設計思想：確固たる基盤と動的メタプログラミング

## 1. プレーンな解決モデルの確立

複雑な ScopeID やマングリングによる自動的な衛生性を一旦廃止し、純粋なレキシカル・スコープと親子環境チェーンのみで動作する基盤を確立した。

- **明示的な評価制御**: `interpreter.eval` は、Atom を評価して得られた `Apply` ノード（関数定義）を勝手に実行せず、そのまま「関数という値」として扱う。これにより、マクロ内での演算子の受け渡しが安全になった。
- **(fun args) 形式の厳格化**: 文法を Lisp らしい括弧付き形式に統一したことで、パースの曖昧さが排除され、マクロのボディ（ラムダ式）を確実にデータとしてキャプチャ可能になった。

## 2. 第一級マクロの実装

マクロ展開エンジン（Expander）と環境操作ツールの統合により、以下の機能が実証された。

- **遅延評価型マクロ**: マクロのボディは登録時には評価されず、展開時に初めて呼び出し側の動的なコンテキストで評価される。
- **make-apply によるコード生成**: `cons` リストを介して動的に引数を組み立て、実引数を解決した上で新しい実行可能ノードを生成する仕組みが完成した。

## 3. 判明した課題：衛生性への新しいアプローチ

プレーンな環境では、マクロ内の識別子が呼び出し側の同名シンボルによって予期せず上書きされる「衝突」が発生する。

### 次なる戦略
- **Quote / Unquote**: `(quote node)` マクロを導入し、評価を明示的に停止・再開する手段を提供する。
- **明示的キャプチャ**: 自動的なマングリングに頼るのではなく、プログラマが `quote` や `set-in` を使って「どの環境のどの値をキャプチャするか」を制御する、より第一級性の高い衛生性を設計する。

## 4. マイルストーンの達成

マクロによって動的に組み立てられた `(+ 10 5)` が正しく `15` を出力したことは、Romanesco のメタプログラミング能力が安定した基盤の上に到達したことを示している。
