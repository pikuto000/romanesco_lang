# Romanesco 言語設計思想：逐次再起動アーキテクチャと衛生的なメタプログラミング

Romanesco は、構文そのものを動的に書き換えながら実行を継続できる、極めて柔軟かつ安全なメタプログラミング環境を提供します。

## 1. 逐次再起動（Sequential Restart）実行モデル

Romanesco はソースコードを一度に全てコンパイルするのではなく、式（Expression）を一つずつパース・実行し、環境の変化に応じて動的に処理を再構成します。

- **ワン・バイ・ワン実行**: ソースコードから 1 つの式を切り出し、即座に展開（Expand）および評価（Eval）を行います。
- **動的再パース**: 新しいマクロやデリミタ（記号）が登録された場合、その時点でのソースコードの残りから、最新の環境を用いてレクサーとパーサーを再生成し、実行を再開します。

## 2. 衛生的なマクロシステム (Hygiene)

Romanesco は、Lisp 的なパワーを維持しつつ、Scheme 的な「衛生性」を導入することで、意図しない変数名の衝突（Variable Capture）を自動的に回避します。

- **`quote` によるマングリング**: `quote` マクロは AST を保留する際、その中の識別子（Atom）に現在のスコープIDを刻印します。
- **自動的な名前の分離**: 刻印された識別子は、実行時に `name__ID` という形式で解決されるため、マクロ内部の変数と外部の変数が衝突することはありません。
- **隔離された実行環境**: マクロの展開コードは、呼び出し側のユーザー環境を直接見ることができない独立したスコープで実行されます。呼び出し側への干渉は `get-macro-env` を通じて明示的に行われます。

## 3. 第一級リーダーマクロ (`macro-reader`)

Romanesco は、パースの挙動自体を Romanesco 自身のコードで記述可能です。

- **動的トークン制御**: `macro-reader` プリミティブにより、任意の開始文字・終了文字をデリミタとして登録し、その間のトークンストリームを処理するラムダを指定できます。
- **疎結合な設計**: パーサーは特定の記号をハードコードしておらず、トークンテーブルの状態に基づいて動的にカスタムパーサーを起動します。

## 4. 統一されたノード・アーキテクチャ

- **匿名ノード**: 定数や関数を `Node` トレイトを実装した匿名オブジェクトとして AST に直接統合しました。
- **透過的な評価**: `interpreter.eval` は全てのノードに対して一貫したインターフェースで動作し、マクロの結果（値または Node）を透過的に扱います。

## 5. 究極の自己拡張性

ユーザーは `defn` や `[` (リストリテラル) といった基本的な言語機能を、全てマクロとして Romanesco 自身で定義できます。これは Romanesco が単なる言語ではなく、独自の言語を構築するための強力なプラットフォームであることを示しています。
