# Romanesco 言語設計思想：逐次再起動アーキテクチャとメタプログラミング

Romanesco は、構文そのものを動的に書き換えながら実行を継続できる、極めて柔軟なメタプログラミング環境を提供します。

## 1. 逐次再起動（Sequential Restart）実行モデル

Romanesco の最大の特徴は、ソースコードを一度に全てコンパイルするのではなく、式（Expression）を一つずつパース・実行し、環境の変化に応じて動的に処理を再構成する点にあります。

- **ワン・バイ・ワン実行**: ソースコードから 1 つの式を切り出し、即座に展開（Expand）および評価（Eval）を行います。
- **動的再パース**: 式の実行によって新しいマクロが登録されるなど、シンタックスに影響を与える変化が発生した場合、その時点でのソースコードの残り（文字オフセットベース）から、最新の環境を用いてレクサーとパーサーを再生成し、実行を再開します。
- **無限ループの防止**: ソースコードは必ず消費されていくため、静的なパースと動的な実行が高度に同期しており、構文変更によるパースの不整合を根絶しています。

## 2. ASTベースのマクロシステム (`macro-ast`)

マクロは第一級の市民であり、展開フェーズ（Expansion Phase）において AST（抽象構文木）を直接操作します。

- **arity 2 の統一**: `macro-ast` は「名前」と「実装（ラムダ）」の 2 引数を受け取ります。
- **展開器 (Expander)**: パースされたノードがマクロである場合、インタープリタによる評価の前に `Expander` がマクロを実行し、その結果を再帰的に展開します。
- **コンテキストの伝播**: マクロ内では `(get-macro-env)` を通じて呼び出し元の環境にアクセスでき、`(set-in)` を用いて呼び出し元のスコープへ値を注入することが可能です。

## 3. プレーンなレキシカルスコープ

複雑な識別子マングリングを排し、単純明快な親子チェーンによるレキシカルスコープを採用しています。

- **関数と値の等価性**: `interpreter.eval` は、Atom を解決して得られた `Apply` ノードを自動的に実行しません。これにより、マクロの引数として関数そのものを安全に渡すことが可能です。
- **ConstantNode**: 評価済みの定数や関数オブジェクトを AST 内に保持するための専用ノード。これにより、評価とパースの境界を安全に越えることができます。

## 4. 堅牢性と安全装置

- **再帰制限**: `eval` および `expand` には深さ制限（デフォルト 100〜1000）が設けられており、無限再帰によるスタックオーバーフローを防止します。
- **厳密なアリティ**: 関数やマクロは固定長引数を基本とし、パーサーが不必要に後続のトークンを飲み込む（Over-consumption）ことを防いでいます。

## 5. 実証された能力

ユーザーが自分自身で `defn` のような基本的な定義構文をマクロとして実装し、それを使って定義した変数を即座に利用できることが実証されました。これは Romanesco が「言語を作るための言語」として完成したことを意味します。