# Romanesco 言語設計思想と実装アーキテクチャ

## 1. 基本記号の意味論 (Semantics of Core Symbols)

Romanesco では、計算を単なる値の簡約ではなく、制約の解決と項の導出のプロセスとして捉える。

- **`\` (Lambda)**: 構造の抽象化。3つの引数 `(Arg, Expr, ApplyArg)` を取る。
    - `ApplyArg` に `_` を渡すと、関数（クロージャ）を返す（定義）。
    - `ApplyArg` に値を渡すと、その場で関数を適用して結果を返す（IIFE）。
- **`:-` (Clause)**: 名前、制約（Constraint）、実体の紐付け。
    - 定義された名前は、その実体が関数であれば自動的に適切なアリティ（引数数）を持つ演算子としてシンボルテーブルに登録される。
- **`_` (Wildcard)**: 
    - **制約**: 「今はどうでもいい」ことを表す受動的な不在。
    - **部分適用**: 演算子の引数として渡された場合、その位置を「穴」として残した新しい関数（クロージャ）を生成して返す。
- **`?` (Term)**: 「導出・解決されるべき変数」。Prolog の論理変数に近く、式を成立させるための能動的な空白を表す。（将来的な構想）

## 2. 実装アーキテクチャ (Implementation Architecture)

### 純粋な評価器 (Pure Interpreter)
`interpreter.scala` は特定の演算子や構文糖衣（`_` や `""` など）に関する知識を持たない。
`Node` ツリーをトラバースし、`Apply` ノードであればその `func` を呼び出すだけの純粋な評価器として機能する。

### 組み込み関数へのロジック移譲
言語機能の多くは、インタプリタではなく「組み込み関数の振る舞い」として実装されている（`src/misc.scala`）。

- **自動カリー化 (Auto-Currying)**:
    `strict` ヘルパー関数により、標準演算子（`+`, `-` 等）は引数に `_` が含まれている場合、自動的に部分適用された関数を返す。
- **構造的適用 (Structural Application)**:
    空文字 `""` を名前とする演算子が登録されており、`(f x)` のような並置（Juxtaposition）を処理する。第1引数を関数として評価し、第2引数をそれに適用する。

### パーサーの役割
- **項ベースのパース**: 貪欲な先読みを避け、`term` 単位でパースすることで、演算子のアリティに基づいた正確な構造解析を行う。
- **並置のデータ化**: 括弧 `(...)` 内の並置は、`Apply("", [acc, arg], func)` というデータ構造に変換される。

## 3. 静的制約型付け (Static Constraint Typing)

- `:- Name Constraint Expr` の形式を取り、`Constraint` 部に具体的な式を記述することで、型を自由に制限できる。
- 将来的には Scala 実装であることを活かし、SMT ソルバー（Z3 等）を導入して、これらの制約をコンパイル時に検証・解決することを検討している。

## 4. コンパイル時メタプログラミング (Macro System)

Romanesco のマクロは、単なるコードの置き換えを超え、言語そのものを全く別のものに変容させる力を持つ。（構想段階）

### アーキテクチャの階層
1.  **リーダー・マクロ (Token Level)**: 文字レベル、トークン制御レベルから制御をマクロに委譲する。
2.  **構文トランスフォーマー (Structural Level)**: `Apply` ノードのツリーをデータ構造として受け取り、別の構造へ書き換える。
3.  **事前計算レイヤー (Compile-time Eval)**: コンパイル時に実行可能なコードを評価し、定数畳み込みや最適化を行う。

この階層構造により、コア（Interpreter/Parser）をシンプルに保ちつつ、ユーザーレベルで複雑な構文や DSL を実現する。