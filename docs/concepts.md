# Romanesco 言語設計思想とマクロ構想（最新版）

## 1. 基本記号の意味論 (Semantics of Core Symbols)

Romanesco では、計算を単なる値の簡約ではなく、制約の解決と項の導出のプロセスとして捉える。

- **`\` (Lambda)**: 構造の抽象化。3引数を取り、`\ Arg Expr ApplyArg` の形式で記述する。
- **`:-` (Clause)**: 名前、制約（Constraint）、実体の紐付け。
- **`_` (Wildcard)**: 「今はどうでもいい」ことを表す受動的な不在。
- **`?` (Term)**: 「導出・解決されるべき変数」。Prolog の論理変数に近く、式を成立させるための能動的な空白。将来的には SMT ソルバーによる解決を視野に入れている。

## 2. アーキテクチャの純粋化

### インタプリタの純粋性
- `interpreter.eval` は特定の構文に依存しない純粋な評価器である。
- 部分適用や構造的適用などの言語機能は、組み込み関数側（`strict` ヘルパー等）の振る舞いとして実装されている。

### レキサーとパーサーの分離
- **`rLexer`**: 文字列をトークン (`rToken`) ストリームに変換。
- **`rParser`**: トークンストリームから AST (`Node`) を構築。`PackratParsers` によるメモ化をサポート。
- **逐次実行**: `Main.scala` はトップレベルの式を一つずつパース・実行する。これにより、実行時に定義された新しい演算子（`:-`）が、即座に以降のパース結果に影響を与える動的な文法変更が可能となっている。

## 3. マクロシステム：「編集者」としてのメタプログラミング

Romanesco におけるマクロは、特定のノード型ではなく、プログラムを書き換える「編集者（Editor）」という役割を持つ第一級の関数である。

### 同図像性の維持
- マクロ専用の AST ノードは存在しない。プログラムは常に `Apply` と `Atom` のみで表現される。
- 「何がマクロか」は `SymbolTable` に付随するメタ情報と `Expander` フェーズによって決定される。

### 編集者の階層
1.  **字句編集者 (Lexer-level / `macro-char`)**: 文字ストリームを操作。
2.  **構造編集者 (AST-level / `macro_ast`)**: AST をデータとして受け取り、別の AST へ変換。
3.  **事前計算編集者 (Compile-time Eval / `comptime`)**: 展開時に式を評価し、結果を `Atom` として埋め込む（定数畳み込み）。

### 衛生性 (Hygiene) と依存関係グラフ
- 衛生性を確保するため、`SymbolTable` は単なる Map ではなく、親子関係を持つスコープとして実装されている。
- 将来的には、シンボルテーブルに「依存関係グラフ」の機能を組み込み、マクロによって生成された名前の衝突や不整合を動的に検知・エラーにする仕組みを検討している。

## 4. コンテキストの循環 (Context Cycle)

- **`RomanescoContext`**: `SymbolTable`, `rLexer`, `rParser` を一つの実行単位としてカプセル化。
- マクロ実行中に別の（あるいは自身の）コンテキストを呼び出すことで、「パース結果をさらにパースする」といった循環的な処理を実現し、言語が動的に「別の言語に化ける」ための基盤を提供する。