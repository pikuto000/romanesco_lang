# Romanesco 言語設計思想：逐次再起動アーキテクチャと究極の疎結合性

Romanesco は、構文と意味を動的に書き換えながら実行を継続できる、極めて柔軟かつ安全なメタプログラミング環境を提供します。

## 1. 逐次再起動（Sequential Restart）実行モデル

Romanesco はソースコードを一度に全てコンパイルするのではなく、式（Expression）を一つずつパース・評価し、環境の変化に応じて動的に処理を再構成します。

- **動的再起動**: 新しいマクロやデリミタ（記号）が登録された場合、その時点でのソースコードの残りから、最新の環境を用いてレクサーとパーサーを再生成し、実行を再開します。

## 2. 衛生的なマクロシステム (Hygiene)

Romanesco は、Lisp 的なパワーを維持しつつ、Scheme 的な「衛生性」を導入することで、意図しない変数名の衝突を自動的に回避します。

- **自動マングリング**: `quote` マクロは AST 内の識別子に現在のスコープ ID を刻印します。これにより、マクロ内部の変数と外部の変数が衝突することはありません。
- **孤立した実行環境**: マクロの展開コードは、呼び出し側のユーザー環境を直接見ることができない独立したスコープで実行されます。干渉は `get-macro-env` を通じて明示的に行われます。

## 3. 究極の疎結合性と匿名ノード

Romanesco のコアは、特定のデータ構造やマクロのセマンティクスに依存しない「純粋なエンジン」を目指しています。

- **専用ノードクラスの廃止**: `ConstantNode` や `QuotedNode` といった専用クラスを廃止しました。代わりに、Node インターフェースを実装した **匿名オブジェクト** をその場で生成し、AST に統合します。
- **セマンティクスの外部化**: 「リストとは何か」「クォートとは何か」といった言語の挙動の多くは `parser.scala`（コア）ではなく `misc.scala`（拡張層）で定義されています。
- **動的トークン制御**: `macro-reader` プリミティブにより、任意の開始文字・終了文字をデリミタとして登録し、その間のパースロジックを Romanesco 自身の関数で記述できます。

## 4. 透過的な評価モデル

`interpreter.eval` は、渡されたものが「パースされたコード」なのか「計算済みの値（匿名ノード）」なのかを意識しません。全ての Node に対して一貫して `eval` を呼び出すことで、複雑なメタプログラミングを透過的に処理します。

## 5. 自己完結する進化

ユーザーは `defn` や `[` (リストリテラル) といった基本的な言語機能を、マクロとして Romanesco 自身で定義できます。Romanesco は「言語を作るための言語」として、最小限のコアと最大限の拡張性を提供します。